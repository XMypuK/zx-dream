<style>
	.zxdebug-toolbar {
		font-size: 14px;
		border-top: 1px solid #444444;
		border-left: 1px solid #444444;
		border-right: 1px solid #444444;
	}

	.zxdebug-registers {
		font-family: Courier New, monospace; 
		font-size: 14px;
		margin-bottom: 10px;
	}

	.zxdebug-registers td, .zxdebug-registers th {
		text-align: center;
	}

	.zxdebug-registers .changed {
		color: #ff0000;
	}

	.zxdebug-trace {
		font-family: Courier New, monospace; 
		font-size: 14px;
		border: 1px solid #444444;
		padding: 0px 0px;
		display: inline-block;
		width: 49%;
		float: left;
	}

	.zxdebug-trace .dasm-line {
		padding: 0px 5px;
	}

	.zxdebug-trace .dasm-line-active {
		padding: 0px 5px;
		background-color: #444444;
		color: #ffffff;
	}

	.zxdebug-trace .addr {
		width: 50px;
		display: inline-block;
	}

	.zxdebug-trace .bytes {
		width: 80px;
		display: inline-block;
	}

	.zxdebug-memory {
		font-family: Courier New, monospace; 
		font-size: 14px;
		border: 1px solid #444444;
		padding: 0px 0px;
		display: inline-block;
		width: 49%;
		float: right;
	}

	.zxdebug-memory .mem-line {
		padding: 0px 5px;
	}

	.zxdebug-memory .addr {
		width: 50px;
		display: inline-block;
	}
</style>

<template id="toolbar">
	<div class="zxdebug-toolbar">
		<input type="checkbox" id="zxdebug_cb_hex" checked /><label for="zxdebug_cb_hex">hex</label>
		<input type="button" id="zxdebug_btn_step_in" value="step in (I)" />
		<input type="button" id="zxdebug_btn_step_out" value="step out (O)" />
		<input type="button" id="zxdebug_btn_step_to" value="step to (T)" />
		<input type="button" id="zxdebug_btn_mem_addr" value="mem address (M)" />
		<input type="button" id="zxdebug_btn_mem_add_08h" value="+8" />
		<input type="button" id="zxdebug_btn_mem_sub_08h" value="-8" />
		<input type="button" id="zxdebug_btn_mem_add_80h" value="+80h" />
		<input type="button" id="zxdebug_btn_mem_sub_80h" value="-80h" />
		<input type="checkbox" id="zxdebug_cb_words" /><label for="zxdebug_cb_words">words</label>
		<input type="button" id="zxdebug_btn_toggle_bp" value="toggle BP (B)" />
		<input type="button" id="zxdebug_btn_run_break" value="run / break (R)" />
	</div>
</template>

<template id="registers">
	<div class="zxdebug-registers">
		<table border="1" style="border-collapse: collapse;" cellpadding="2" width="100%">
			<tr>
				<th colspan="2">AF</th>
				<th colspan="2">BC</th>
				<th colspan="2">DE</th>
				<th colspan="2">HL</th>
				<th colspan="2">IX</th>
				<th colspan="2">IY</th>
				<th colspan="2">PC</th>
				<th colspan="2">SP</th>
				<th colspan="2">AF'</th>
				<th colspan="2">BC'</th>
				<th colspan="2">DE'</th>
				<th colspan="2">HL'</th>
			</tr>
			<tr>
				<td id="zxdebug_r_af" colspan="2"></td>
				<td id="zxdebug_r_bc" colspan="2"></td>
				<td id="zxdebug_r_de" colspan="2"></td>
				<td id="zxdebug_r_hl" colspan="2"></td>
				<td id="zxdebug_r_ix" colspan="2"></td>
				<td id="zxdebug_r_iy" colspan="2"></td>
				<td id="zxdebug_r_pc" colspan="2"></td>
				<td id="zxdebug_r_sp" colspan="2"></td>
				<td id="zxdebug_r_af_" colspan="2"></td>
				<td id="zxdebug_r_bc_" colspan="2"></td>
				<td id="zxdebug_r_de_" colspan="2"></td>
				<td id="zxdebug_r_hl_" colspan="2"></td>
			</tr>
			<tr>
				<td id="zxdebug_r_a"></td>
				<td id="zxdebug_r_f"></td>
				<td id="zxdebug_r_b"></td>
				<td id="zxdebug_r_c"></td>
				<td id="zxdebug_r_d"></td>
				<td id="zxdebug_r_e"></td>
				<td id="zxdebug_r_h"></td>
				<td id="zxdebug_r_l"></td>
				<td rowspan="2" colspan="8">
					<table width="100%">
						<tr>
							<td id="zxdebug_f_s" width="16%"></td>
							<td id="zxdebug_f_z" width="16%"></td>
							<td id="zxdebug_f_h" width="16%"></td>
							<td id="zxdebug_f_p" width="16%"></td>
							<td id="zxdebug_f_n" width="16%"></td>
							<td id="zxdebug_f_c" width="16%"></td>
						</tr>
						<tr>
							<th>S</th>
							<th>Z</th>
							<th>H</th>
							<th>P/V</th>
							<th>N</th>
							<th>C</th>
						</tr>							
					</table>						
				</td>
				<td colspan="2"></td>
				<td id="zxdebug_iff" colspan="2"></td>
				<td id="zxdebug_imf" colspan="2"></td>
				<td id="zxdebug_r_i"></td>
				<td id="zxdebug_r_r"></td>
			</tr>
			<tr>
				<th width="4.16%">A</th>
				<th width="4.16%">F</th>
				<th width="4.16%">B</th>
				<th width="4.16%">C</th>
				<th width="4.16%">D</th>
				<th width="4.16%">E</th>
				<th width="4.16%">H</th>
				<th width="4.16%">L</th>
				<th width="8.32%" colspan="2"></th>
				<th width="8.32%" colspan="2">IFF</th>
				<th width="8.32%" colspan="2">IMF</th>
				<th width="4.16%">I</th>
				<th width="4.16%">R</th>
			</tr>
		</table>
	</div>
</template>

<template id="trace-block">
	<div id="zxdebug_dasm" class="zxdebug-trace"></div>
</template>

<template id="memory-block">
	<div id="zxdebug_memory" class="zxdebug-memory"></div>
</template>

<script type="text/javascript">
	var zxdebug = new (function() {
		// public
		this.debug = debug;


		// private
		var self = this;
		var hex = true;
		var break_points = [];
		var running = false;
		var break_request = false;
		var settings = null;
		var bus = null;
		var z80 = null;
		var display = null;

		function debug( container, _z80, _bus, _display, _settings ) {
			settings = _settings;
			z80 = _z80;
			bus = _bus;
			display = _display;

			self.toolbar = new Toolbar(container, on_user_command);
			self.registers = new RegistersBlock(container, z80);
			self.disasm = new DisasmBlock(container, z80, bus);
			self.memory = new MemoryBlock(container, bus);

			self.toolbar.enable();
			self.registers.update(true);
			self.disasm.update();
			self.memory.update();
		}

		function on_user_command(cmd, args) {
			switch (cmd) {
				case 'hex': 
					hex = args.checked; 
					self.registers.update(false);
					self.disasm.update();
					self.memory.update();
					break;

				case 'step_in': step_in(); break;
				case 'step_out': step_out(); break;
				case 'step_to': step_to(); break;
				case 'change_memory_address': self.memory.change_memory_address(); break;
				case 'shift_memory_address': self.memory.shift_memory_address(args.offset); break;
				case 'words': self.memory.display_words(args.checked); break;
				case 'toggle_break_point': toggle_break_point(); break;
				case 'run_break': run_break(); break;
			}
		}

		function step_in() {
			self.toolbar.disable();

			var state = z80.get_state();
			var cmd = disasm_instruction(bus, state.pc);
			if ( /^(JP|JR|DJNZ|CALL|RST)/.test(cmd.mn) ) {
				// прыжки и вызовы могут передать управление по заданному адресу
				if ( cmd.addr !== undefined ) {
					run_to(cmd.next, cmd.addr);
				}
				else {
					var addr;
					if ( /HL/.test(cmd.mn) ) {
						addr = state.hl;
					}
					else if ( /IX/.test(cmd.mn) ) {
						addr = state.ix;
					}
					else if ( /IY/.test(cmd.mn) ) {
						addr = state.iy;
					}
					else {
						throw Error('Unknown control command');
					}

					run_to(cmd.next, addr);
				}
			}
			else if ( /^RET/.test(cmd.mn) ) {
				// команды RET... может передать управление как следующей команде, так и по адресу в стеке
                var addr = read_memory_word(bus, state.sp);
				run_to(cmd.next, addr);
			}
			else if ( /^(HALT|(LD|CP|IN|OT)[ID]R)/.test(cmd.mn) ) {
				// блочные команды и команда HALT могут откинуть PC на начало команды
				run_to(cmd.next, state.pc);
			}
			else {
				run_to(cmd.next);
			}			
		}

		function step_out() {
			self.toolbar.disable();

			var state = z80.get_state();
			var cmd = disasm_instruction(bus, state.pc);
			if ( /^(JP|JR|DJNZ)/.test(cmd.mn) ) {
				if ( cmd.addr !== undefined ) {
					run_to(cmd.next, cmd.addr);
				}
				else {
					var addr;
					if ( /HL/.test(cmd.mn) ) {
						addr = state.hl;
					}
					else if ( /IX/.test(cmd.mn) ) {
						addr = state.ix;
					}
					else if ( /IY/.test(cmd.mn) ) {
						addr = state.iy;
					}
					else {
						throw Error('Unknown control command');
					}

					run_to(cmd.next, addr);
				}
			}
			else if ( /^RET/.test(cmd.mn) ) {
                var addr = read_memory_word(bus, state.sp);
				run_to(cmd.next, addr);
			}
			else {
				run_to(cmd.next);
			}
		}

		function step_to() {
			var str_address = prompt('Введите адрес точки останова:', '');
			if ( str_address != null ) {
				str_address = str_address.replace(/^\s+|\s+$/g, '');
				var radix = 10;
				if (str_address.length && str_address.charAt(str_address.length - 1).toLowerCase() == 'h') {
					radix = 16;
				}
				if (str_address.length >= 2 & str_address.charAt(0) == '0' && str_address.charAt(1).toLowerCase() == 'x') {
					radix = 16;
				}
				var addr = parseInt(str_address, radix);
				if (!isNaN(addr)) {
					self.toolbar.disable();
					run_to(addr);
				}
			}
		}

		function run_break() {
			if ( running ) {
				break_request = true;
			}
			else {
				self.toolbar.disable();
				run_to(-1);
			}
		}

		function toggle_break_point() {
			var str_address = prompt('Введите адрес точки останова:', '');
			if ( str_address != null ) {
				str_address = str_address.replace(/^\s+|\s+$/g, '');
				var radix = 10;
				if (str_address.length && str_address.charAt(str_address.length - 1).toLowerCase() == 'h') {
					radix = 16;
				}
				if (str_address.length >= 2 & str_address.charAt(0) == '0' && str_address.charAt(1).toLowerCase() == 'x') {
					radix = 16;
				}
				var addr = parseInt(str_address, radix);
				if (!isNaN(addr)) {
					var deleted = false;
					for (var i = 0; i < break_points.length; i++) {
						if ( break_points[ i ] == addr ) {
							break_points.splice(i, 1);
							deleted = true;
							alert('Точка останова удалена');
							break;
						}
					}

					if (!deleted) {
						break_points.push(addr);
						alert('Точка останова добавлена');
					}
				}
			}
		}


		function run_to(address1, address2) {
			running = true;

			var tstates_per_int = settings.turbo_mode ? settings.tstates_per_int_min : settings.turbo_tstates_per_int_min;

			while (true) {
				if ( z80.get_ts_cnt() >= tstates_per_int ) {
					display.redraw();

					z80.intrq();
					z80.set_ts_cnt(0);
					setTimeout(function() { run_to(address1, address2); }, 0);
					return;
				}

				z80.process();

				var state = z80.get_state();
				var bp = ( state.pc == address1 ) || ( state.pc == address2 );
				if (!bp) {
					for (var i = 0; i < break_points.length; i++) {
						if ( state.pc == break_points[i] ) {
							bp = true;
							break;
						}
					}
				}

				if ( bp || break_request ) {
					display.redraw();

					self.toolbar.enable();
					self.registers.update(true);
					self.disasm.update();
					self.memory.update();
					running = false;
					break_request = false;
					return;
				}
			}
		}

		function Toolbar(container, handler) {
			// public
			this.disable = disable;
			this.enable = enable;

			// private
			var toolbar = document.createElement('div');
			toolbar.innerHTML = "<?=toolbar?>";
			container.appendChild(toolbar.children[0]);

			var cb_hex = document.getElementById('zxdebug_cb_hex');
			var btn_step_in = document.getElementById('zxdebug_btn_step_in');
			var btn_step_out = document.getElementById('zxdebug_btn_step_out');
			var btn_step_to = document.getElementById('zxdebug_btn_step_to');
			var btn_mem_addr = document.getElementById('zxdebug_btn_mem_addr');
			var btn_mem_add_08h = document.getElementById('zxdebug_btn_mem_add_08h');
			var btn_mem_sub_08h = document.getElementById('zxdebug_btn_mem_sub_08h');
			var btn_mem_add_80h = document.getElementById('zxdebug_btn_mem_add_80h');
			var btn_mem_sub_80h = document.getElementById('zxdebug_btn_mem_sub_80h');
			var cb_words = document.getElementById('zxdebug_cb_words');
			var btn_toggle_bp = document.getElementById('zxdebug_btn_toggle_bp');
			var btn_run_break = document.getElementById('zxdebug_btn_run_break')

			var disabled = false;

			function enable() {
				disabled = false;
				cb_hex.disabled = false;
				btn_step_in.disabled = false;
				btn_step_out.disabled = false;
				btn_step_to.disabled = false;
				btn_mem_addr.disabled = false;
				btn_mem_add_08h.disabled = false;
				btn_mem_sub_08h.disabled = false;
				btn_mem_add_80h.disabled = false;
				btn_mem_sub_80h.disabled = false;
				cb_words.disabled = false;
				//btn_toggle_bp.disabled = false;
				//btn_run_break.disabled = false;
			}

			function disable() {
				disabled = true;
				cb_hex.disabled = true;
				btn_step_in.disabled = true;
				btn_step_out.disabled = true;
				btn_step_to.disabled = true;
				btn_mem_addr.disabled = true;
				btn_mem_add_08h.disabled = true;
				btn_mem_sub_08h.disabled = true;
				btn_mem_add_80h.disabled = true;
				btn_mem_sub_80h.disabled = true;
				cb_words.disabled = true;	
				//btn_toggle_bp.disabled = true;
				//btn_run_break.disabled = true;							
			}


			if (document.addEventListener) {
				document.addEventListener('keydown', onkeydown, false);
			}
			else {
				document.attachEvent('onkeydown', onkeydown);
			}

			function onkeydown(e) {
				var e = e || window.event;

				switch (e.keyCode) {
					case 0x42: do_command('toggle_break_point'); break;
					case 0x52: do_command('run_break'); break;
				}

				if ( disabled ) {
					return;
				}

				
				switch (e.keyCode) {
					case 0x48: 
						cb_hex.checked = !cb_hex.checked;
						do_command('hex', { checked: cb_hex.checked });
						break;

					case 0x49: do_command('step_in'); break;
					case 0x4f: do_command('step_out'); break;
					case 0x54: do_command('step_to'); break;
					case 0x4d: do_command('change_memory_address'); break;
					case 0x2b:
					case 0x6b: do_command('shift_memory_address', { offset: 0x08 }); break;
					case 0x2d:
					case 0x6d: do_command('shift_memory_address', { offset: -0x08 }); break;
					case 0x21: do_command('shift_memory_address', { offset: -0x80 }); break;
					case 0x22: do_command('shift_memory_address', { offset: 0x80 }); break;
					case 0x57: 
						cb_words.checked = !cb_words.checked;
						do_command('words', { checked: cb_words.checked });
						break;

					default: return;
				}

				e.preventDefault ? e.preventDefault() : ( e.returnValue = false );
			}

			cb_hex.onclick = function() { do_command('hex', { checked: cb_hex.checked }); };		
			btn_step_in.onclick = function() { do_command('step_in'); };
			btn_step_out.onclick = function() { do_command('step_out'); };
			btn_step_to.onclick = function() { do_command('step_to'); };
			btn_mem_addr.onclick = function() { do_command('change_memory_address'); };
			btn_mem_add_08h.onclick = function() { do_command('shift_memory_address', { offset: 0x08 }); };
			btn_mem_sub_08h.onclick = function() { do_command('shift_memory_address', { offset: -0x08 }); };
			btn_mem_add_80h.onclick = function() { do_command('shift_memory_address', { offset: 0x80 }); };
			btn_mem_sub_80h.onclick = function() { do_command('shift_memory_address', { offset: -0x80 }); };
			cb_words.onclick = function() { do_command('words', { checked: cb_words.checked }); };
			btn_toggle_bp.onclick = function() { do_command('toggle_break_point'); };
			btn_run_break.onclick = function() { do_command('run_break'); };


			function do_command(command, args) {
				handler(command, args);
			}
		}

		function RegistersBlock(container, z80) {
			// public
			this.update = update;

			// private
			var registers = document.createElement('div');
			registers.innerHTML = "<?=registers?>";
			container.appendChild(registers.children[0]);

			var r_pc = document.getElementById('zxdebug_r_pc');
			var r_sp = document.getElementById('zxdebug_r_sp');
			var r_ix = document.getElementById('zxdebug_r_ix');
			var r_iy = document.getElementById('zxdebug_r_iy');
			var r_hl = document.getElementById('zxdebug_r_hl');
			var r_h  = document.getElementById('zxdebug_r_h');
			var r_l  = document.getElementById('zxdebug_r_l');
			var r_de = document.getElementById('zxdebug_r_de');
			var r_d  = document.getElementById('zxdebug_r_d');
			var r_e  = document.getElementById('zxdebug_r_e');
			var r_bc = document.getElementById('zxdebug_r_bc');
			var r_b  = document.getElementById('zxdebug_r_b');
			var r_c  = document.getElementById('zxdebug_r_c');
			var r_af = document.getElementById('zxdebug_r_af');
			var r_a  = document.getElementById('zxdebug_r_a');
			var r_f  = document.getElementById('zxdebug_r_f');
			var r_hl_= document.getElementById('zxdebug_r_hl_');
			var r_de_= document.getElementById('zxdebug_r_de_');
			var r_bc_= document.getElementById('zxdebug_r_bc_');
			var r_af_= document.getElementById('zxdebug_r_af_');
			var r_i  = document.getElementById('zxdebug_r_i');
			var r_r  = document.getElementById('zxdebug_r_r');
			var f_s  = document.getElementById('zxdebug_f_s');
			var f_z  = document.getElementById('zxdebug_f_z');
			var f_h  = document.getElementById('zxdebug_f_h');
			var f_p  = document.getElementById('zxdebug_f_p');
			var f_n  = document.getElementById('zxdebug_f_n');
			var f_c  = document.getElementById('zxdebug_f_c');
			var iff  = document.getElementById('zxdebug_iff');
			var imf  = document.getElementById('zxdebug_imf');

			var last_state = z80.get_state();

			function update( update_styles ) {
				var state = z80.get_state();

				// значения
				r_pc.innerHTML = word_to_string(state.pc);
				r_sp.innerHTML = word_to_string(state.sp);
				r_ix.innerHTML = word_to_string(state.ix);
				r_iy.innerHTML = word_to_string(state.iy);

				r_hl.innerHTML = word_to_string(state.hl);
				r_h.innerHTML = byte_to_string(state.hl >> 8);
				r_l.innerHTML = byte_to_string(state.hl & 0xff);

				r_de.innerHTML = word_to_string(state.de);
				r_d.innerHTML = byte_to_string(state.de >> 8);
				r_e.innerHTML = byte_to_string(state.de & 0xff);

				r_bc.innerHTML = word_to_string(state.bc);
				r_b.innerHTML = byte_to_string(state.bc >> 8);
				r_c.innerHTML = byte_to_string(state.bc & 0xff);

				r_af.innerHTML = word_to_string(state.af);
				r_a.innerHTML = byte_to_string(state.af >> 8);
				r_f.innerHTML = byte_to_string(state.af & 0xff);

				r_hl_.innerHTML = word_to_string(state.hl_);
				r_de_.innerHTML = word_to_string(state.de_);
				r_bc_.innerHTML = word_to_string(state.bc_);
				r_af_.innerHTML = word_to_string(state.af_);

				r_i.innerHTML = byte_to_string(state.i);
				r_r.innerHTML = byte_to_string(state.r);

				f_s.innerHTML = ( state.af & 0x80 ) ? 1 : 0;
				f_z.innerHTML = ( state.af & 0x40 ) ? 1 : 0;
				f_h.innerHTML = ( state.af & 0x10 ) ? 1 : 0;
				f_p.innerHTML = ( state.af & 0x04 ) ? 1 : 0;
				f_n.innerHTML = ( state.af & 0x02 ) ? 1 : 0;
				f_c.innerHTML = ( state.af & 0x01 ) ? 1 : 0;

				iff.innerHTML = (( state.iff & 0x02 ) ? '1' : '0' ) + (( state.iff & 0x01 ) ? '1' : '0' );
				imf.innerHTML = (( state.imf & 0x02 ) ? '1' : '0' ) + (( state.imf & 0x01 ) ? '1' : '0' );

				if ( update_styles ) {
					// стили
					r_pc.className = ( state.pc != last_state.pc ) ? 'changed' : '';
					r_sp.className = ( state.sp != last_state.sp ) ? 'changed' : '';
					r_ix.className = ( state.ix != last_state.ix ) ? 'changed' : '';
					r_iy.className = ( state.iy != last_state.iy ) ? 'changed' : '';

					r_hl.className = ( state.hl != last_state.hl ) ? 'changed' : '';
					r_h.className = (( state.hl >> 8 ) != ( last_state.hl >> 8 )) ? 'changed' : '';
					r_l.className = (( state.hl & 0xff ) != ( last_state.hl & 0xff )) ? 'changed' : '';

					r_de.className = ( state.de != last_state.de ) ? 'changed' : '';
					r_d.className = (( state.de >> 8 ) != ( last_state.de >> 8 )) ? 'changed' : '';
					r_e.className = (( state.de & 0xff ) != ( last_state.de & 0xff )) ? 'changed' : '';

					r_bc.className = ( state.bc != last_state.bc ) ? 'changed' : '';
					r_b.className = (( state.bc >> 8 ) != ( last_state.bc >> 8 )) ? 'changed' : '';
					r_c.className = (( state.bc & 0xff ) != ( last_state.bc & 0xff )) ? 'changed' : '';

					r_af.className = ( state.af != last_state.af ) ? 'changed' : '';
					r_a.className = (( state.af >> 8 ) != ( last_state.af >> 8 )) ? 'changed' : '';
					r_f.className = (( state.af & 0xff ) != ( last_state.af & 0xff )) ? 'changed' : '';		

					r_hl_.className = ( state.hl_ != last_state.hl_ ) ? 'changed' : '';
					r_de_.className = ( state.de_ != last_state.de_ ) ? 'changed' : '';
					r_bc_.className = ( state.bc_ != last_state.bc_ ) ? 'changed' : '';
					r_af_.className = ( state.af_ != last_state.af_ ) ? 'changed' : '';

					r_i.className = ( state.i != last_state.i ) ? 'changed' : '';
					r_r.className = ( state.r != last_state.r ) ? 'changed' : '';

					f_s.className = (( state.af & 0x80 ) ^ ( last_state.af & 0x80 )) ? 'changed' : '';
					f_z.className = (( state.af & 0x40 ) ^ ( last_state.af & 0x40 )) ? 'changed' : '';
					f_h.className = (( state.af & 0x10 ) ^ ( last_state.af & 0x10 )) ? 'changed' : '';
					f_p.className = (( state.af & 0x04 ) ^ ( last_state.af & 0x04 )) ? 'changed' : '';
					f_n.className = (( state.af & 0x02 ) ^ ( last_state.af & 0x02 )) ? 'changed' : '';
					f_c.className = (( state.af & 0x01 ) ^ ( last_state.af & 0x01 )) ? 'changed' : '';

					iff.className = ( state.iff != last_state.iff ) ? 'changed' : '';
					imf.className = ( state.imf != last_state.imf ) ? 'changed' : '';
				}

				last_state = state;			
			}
		}

		function DisasmBlock(container, z80, bus) {
			// public
			this.update = update;

			// private
			var trace_block = document.createElement('div');
			trace_block.innerHTML = "<?=trace-block?>";
			container.appendChild(trace_block.children[0]);

			var dasm_block = document.getElementById('zxdebug_dasm');

			var buffer_length = 16;
			var buffer = [
				// {
				// 	addr: 0x0038,
				// 	res: { mn: 'NOP', bytes: [ 0x00 ], next: 0x0039 }
				// }
			];

			function get_index_by_addr(addr) {
				for (var i = 0; i < buffer.length; i++) {
					if ( buffer[i].addr == addr ) {
						return i;
					}
				}
				return -1;
			};

			function update() {
				var state = z80.get_state();

				var pc = state.pc;
				if ( state.prefix_dd || state.prefix_fd || state.prefix_ed ) {
					pc--;
				}

				if ( state.prefix_cb ) {
					pc--;
				}

				var index = get_index_by_addr(pc);
				if (index < 0) {
					buffer.splice(0, buffer.length);
					var addr = pc;
					for (var i = 0; i < buffer_length; i++) {
						buffer[i] = {
							addr: addr,
						 	res: disasm_instruction(bus, addr)
						};
						addr = buffer[i].res.next;
					}
					index = 0;
				}

				update_dasm_block(index);
			}

			function update_dasm_block( active_index ) {
				var dasm_html = "";
				for (var i = 0; i < buffer.length; i++) {
					var addr = buffer[i].addr;
					var res = buffer[i].res;
					var mnemonics = res.mn;
					if ( res.addr !== undefined ) {
						mnemonics = mnemonics.replace('addr', word_to_string(res.addr));
					}
					if ( res.offs !== undefined ) {
						var offset = res.offs;
						if ( offset & 0x80 ) {
							offset = -((offset ^ 0xff) + 1);
						}
						mnemonics = mnemonics.replace(/\+\s*offs/gi, (offset >= 0 ? '+ ' : '- ') + byte_to_string(Math.abs(offset)));
					}
					if ( res.val8 !== undefined ) {
						mnemonics = mnemonics.replace('val8', byte_to_string(res.val8));
					}
					if ( res.val16 !== undefined ) {
						mnemonics = mnemonics.replace('val16', word_to_string(res.val16));
					}
					if ( res.port !== undefined ) {
						mnemonics = mnemonics.replace('port', byte_to_string(res.port));
					}

					dasm_html += '<div class="dasm-line' + ( i == active_index ? '-active' : '' ) + '">';
					dasm_html += '<span class="addr">' + word_to_string(addr) + '</span>';
					dasm_html += '<span class="bytes">' + bytes_to_hex_string(res.bytes) + '</span>';
					dasm_html += '<span class="mnemonics">' + mnemonics + '</span>';
					dasm_html += '</div>';
				}

				dasm_block.innerHTML = dasm_html;
			}
		}

		function MemoryBlock(container, bus) {
			// public
			this.shift_memory_address = shift_memory_address;
			this.change_memory_address = change_memory_address;
			this.update = update;
			this.display_words = function(value) {
				if ( value !== undefined ) {
					display_words = value;
					update();
				}
				else {
					return display_words;
				}
			}

			// private
			var memory_block = document.createElement('div');
			memory_block.innerHTML = "<?=memory-block?>";
			container.appendChild(memory_block.children[0]);

			var memory_block = document.getElementById('zxdebug_memory');

			var address = 0x0000;
			var display_words = false;
			var lines = 16;


			function shift_memory_address(offset) {
				address = ( address + offset ) & 0xffff;
				update();
			}

			function change_memory_address() {
				var str_address = prompt('Введите новый адрес: ', '');
				if ( str_address != null ) {
					str_address = str_address.replace(/^\s+|\s+$/g, '');
					var radix = 10;
					if (str_address.length && str_address.charAt(str_address.length - 1).toLowerCase() == 'h') {
						radix = 16;
					}
					if (str_address.length >= 2 & str_address.charAt(0) == '0' && str_address.charAt(1).toLowerCase() == 'x') {
						radix = 16;
					}
					var addr = parseInt(str_address, radix);
					if (!isNaN(addr)) {
						address = addr;
						update();
					}
				}				
			}

			function update() {
				var mem_html = '';

				for (var y = 0; y < lines; y++) {

					var req = {
						mreq: true,
						read: true,
						address: ( address + ( y * 8 )) & 0xffff,
						size: 1
					};

					mem_html += '<div class="mem-line">';
					mem_html += '<span class="addr">' + word_to_string(req.address) + '</span>';
					if ( display_words ) {
						mem_html += '<span class="words">';

						req.size = 2;

						for (var x = 0; x < 4; x++) {

							bus.request(req);
							var word = req.data;
							req.address = ( req.address + 2 ) & 0xffff;

							mem_html += word_to_string(word, { hex: true, dont_suffix: true }) + ' ';
						}

						mem_html += '</span>';
					}
					else {
						mem_html += '<span class="bytes">';

						req.size = 1;

						for (var x = 0; x < 8; x++) {

							bus.request(req);
							var v8 = req.data;
							req.address = ( req.address + 1 ) & 0xffff;

							mem_html += byte_to_string(v8, { hex: true, dont_suffix: true }) + ' ';
						}

						mem_html += '</span>';
					}

					mem_html += '</div>';
				}

				memory_block.innerHTML = mem_html;
			}						
		}

        /////////////////////////////
		// Вспомогательные функции //
		/////////////////////////////

		function byte_to_string(value, options) {
			if ( hex || ( options && options.hex )) {
				var cc1 = (( value >> 4 ) & 0x0f ) + 0x30;
				if ( cc1 > 0x39 ) { cc1 += 0x27; }

				var cc2 = (( value >> 0 ) & 0x0f ) + 0x30;
				if ( cc2 > 0x39 ) { cc2 += 0x27; }

				var s = String.fromCharCode(cc1, cc2);
				if ( !options || !options.dont_suffix ) {
					s += 'h';
				}
				return s;
			}
			else {
				return value.toString();
			}
		}

		function word_to_string(value, options) {
			if ( hex || ( options && options.hex )) {
				var cc1 = (( value >> 12 ) & 0x0f ) + 0x30;
				if ( cc1 > 0x39 ) { cc1 += 0x27; }

				var cc2 = (( value >> 8 ) & 0x0f ) + 0x30;
				if ( cc2 > 0x39 ) { cc2 += 0x27; }

				var cc3 = (( value >> 4 ) & 0x0f ) + 0x30;
				if ( cc3 > 0x39 ) { cc3 += 0x27; }

				var cc4 = (( value >> 0 ) & 0x0f ) + 0x30;
				if ( cc4 > 0x39 ) { cc4 += 0x27; }

				var s = String.fromCharCode(cc1, cc2, cc3, cc4);
				if ( !options || !options.dont_suffix ) {
					s += 'h';
				}
				return s;
			}
			else {
				return value.toString();
			}
		}

		function bytes_to_hex_string (bytes) {
			var s = '';
			for (var i = 0; i < bytes.length; i++) {
				var cc1 = (( bytes[i] >> 4 ) & 0x0f ) + 0x30;
				if ( cc1 > 0x39 ) { cc1 += 0x27; }

				var cc2 = (( bytes[i] >> 0 ) & 0x0f ) + 0x30;
				if ( cc2 > 0x39 ) { cc2 += 0x27; }

				s += String.fromCharCode(cc1, cc2);
			}
			return s;
		}

		function read_opcode_byte(bus, address) {
			var state = {
				mreq: true,
				m1: true,
				read: true,
				address: address,
				data: 0,
				size: 1
			};

			bus.request(state);

			return state.data;
		}
		function read_memory_byte(bus, address) {
			var state = {
				mreq: true,
				read: true,
				address: address,
				data: 0,
				size: 1
			};

			bus.request(state);

			return state.data;
		}

		function read_memory_word(bus, address) {
			return read_memory_byte(bus, address) | ( read_memory_byte(bus, (address + 1) & 0xffff) << 8 ) ;
			// var state = {
			// 	mreq: true,
			// 	read: true,
			// 	address: address,
			// 	data: 0,
			// 	size: 2
			// };

			// bus.request(state);

			// return state.data;			
		}

		function disasm_instruction(bus, address) {
		    var result = {
		        mn: '',
		        next: address,
		        bytes: []
		    };

			var opcode = read_opcode_byte(bus, result.next++);
		    result.bytes.push(opcode);

			var prefix_ix = ( opcode == 0xdd );
			var prefix_iy = ( opcode == 0xfd );
			var prefix_ed = ( opcode == 0xed );
			var prefix_cb = ( opcode == 0xcb );
			var offset = 0;

			if ( prefix_ix || prefix_iy ) {
				opcode = read_opcode_byte(bus, result.next);

				if ( opcode == 0xdd || opcode == 0xfd || opcode == 0xed ) {
					result.mn = 'NOP';
					return result;
				}

		        result.next++;
		        result.bytes.push(opcode);

				if ( opcode == 0xcb ) {
					prefix_cb = true;
					offset = read_memory_byte(bus, result.next++);
		            result.bytes.push(offset);
				}
			}

			if ( prefix_ed ) {
				opcode = read_opcode_byte(bus, result.next++);
		        result.bytes.push(opcode);

		        // 010xx111
		        if ( ( opcode & 0xe7 ) == 0x47 ) {
		            // LD A, I
		            // LD A, R
		            // LD I, A
		            // LD R, A
		            var subcode = (opcode >> 3) & 0x03;
		            switch (subcode) {
		                case 0x00: result.mn = 'LD I, A'; break;
		                case 0x01: result.mn = 'LD R, A'; break;
		                case 0x02: result.mn = 'LD A, I'; break;
		                case 0x03: result.mn = 'LD A, R'; break;
		            }

		            return result;
		        }

		        // 01xxx011
		        if ( (opcode & 0xc7 ) == 0x43 ) {
		            // LD dd, (nn)
		            // LD (nn), dd

		            var to_reg = !!(opcode & 0x08);
		            var dd = (opcode >> 4) & 0x03;

		            var reg_name;
		            switch (dd) {
		            	case 0x00: reg_name = 'BC'; break;
		            	case 0x01: reg_name = 'DE'; break;
		            	case 0x02: reg_name = 'HL'; break;
		            	case 0x03: reg_name = 'SP'; break;
		            }

		            if (to_reg) {
		            	result.mn = 'LD ' + reg_name + ', (addr)';
		            }
		            else { // to_mem
		            	result.mn = 'LD (addr), ' + reg_name;
		            }

		            result.addr = read_memory_word(bus, result.next);
		            result.next += 2;
		            result.bytes.push(result.addr & 0xff);
		            result.bytes.push(result.addr >> 8);

		            return result;
		        }

		        // 101xx000
		        if ( (opcode & 0xe7 ) == 0xa0 ) {
		            // LDI
		            // LDIR
		            // LDD
		            // LDDR

		            var increment = !(opcode & 0x08);
		            var repeat = !!(opcode & 0x10);

		            result.mn = 'LD' + ( increment ? 'I' : 'D' ) + ( repeat ? 'R' : '' );
		            return result;
		        }

		        // 101xx001
		        if ( (opcode & 0xe7 ) == 0xa1 ) {
		            // CPI
		            // CPIR
		            // CPD
		            // CPDR

		            var increment = !(opcode & 0x08);
		            var repeat = !!(opcode & 0x10);

		            result.mn = 'CP' + ( increment ? 'I' : 'D' ) + ( repeat ? 'R' : '' );
		            return result;
		        }

		        // 01xxx100
		        if (( opcode & 0xc7 ) == 0x44 ) {
		            // NEG
		            // * включая все недокументированные варианты опкодов

		            result.mn = 'NEG';
		            return result;
		        }

		        // 01xxx110
		        if ( ( opcode & 0xc7 ) == 0x46 ) {
		            // IM 0
		            // IM 1
		            // IM 2
		            // * включая все недокументированные варианты опкодов

		            switch (( opcode >> 3 ) & 0x03 ) {
		            	case 0x00: result.mn = 'IM 0'; break;
		                case 0x01: result.mn = 'IM 0'; break;
		            	case 0x02: result.mn = 'IM 1'; break;
		            	case 0x03: result.mn = 'IM 2'; break;
		            }

		            return result;
		        }

		        // 01xxx010
		        if ( (opcode & 0xc7 ) == 0x42 ) {
		            // ADC HL, ss
		            // SBC HL, ss

		            var addition = !!(opcode & 0x08);
		            var ss = (opcode >> 4) & 0x03;

		            var reg_name;
		            switch (ss) {
		            	case 0x00: reg_name = 'BC'; break;
		            	case 0x01: reg_name = 'DE'; break;
		            	case 0x02: reg_name = 'HL'; break;
		            	case 0x03: reg_name = 'SP'; break;
		            }

		            result.mn = ( addition ? 'ADC HL, ' : 'SBC HL, ') + reg_name;
		            return result;
		        }

		        // 0110x111
		        if ( (opcode & 0xf7 ) == 0x67 ) {
		            // RLD
		            // RRD

		            var left = !!(opcode & 0x08);

		            result.mn = left ? 'RLD' : 'RRD';
		            return result;
		        }

		        // 01xxx101
		        if ( (opcode & 0xc7 ) == 0x45 ) {
		            // RETI
		            // RETN
		            // * включая все недокументированные варианты опкодов

		            result.mn = 'RET' + (( opcode & 0x80 ) ? 'I' : 'N' );
		            return result;
		        }

		        // 01xxx00x
		        if ( ( opcode & 0xc6 ) == 0x40 ) {
		            // IN r, (C)
		            // OUT (C), r
                	// * IN 0, (C)
                	// * OUT (C), 0

		            var r1 = (opcode >> 3) & 0x07;
		            var cmd_in = !(opcode & 0x01);

		            var reg_name;
		            switch (r1) {
		            	case 0x00: reg_name = 'B'; break;
		            	case 0x01: reg_name = 'C'; break;
		            	case 0x02: reg_name = 'D'; break;
		            	case 0x03: reg_name = 'E'; break;
		            	case 0x04: reg_name = 'H'; break;
		            	case 0x05: reg_name = 'L'; break;
		            	case 0x06: reg_name = '0'; break;
		            	case 0x07: reg_name = 'A'; break;
		            }

		            if (cmd_in) {
		            	result.mn = 'IN ' + reg_name + ', (C)';
		            }
		            else {
		            	result.mn = 'OUT (C), ' + reg_name;
		            }

		            return result;
		        }

		        // 101xx01x
		        if ( (opcode & 0xe6 ) == 0xa2 ) {
		            // INI
		            // INIR
		            // IND
		            // INDR
		            // OUTI
		            // OTIR
		            // OUTD
		            // OTDR

		            var repeat = !!(opcode & 0x10);
		            var increment = !(opcode & 0x08);
		            var cmd_in = !(opcode & 0x01);

		            if (cmd_in) {
		            	result.mn = 'IN' + ( increment ? 'I' : 'D' ) + ( repeat ? 'R' : '' );
		            }
		            else {
		            	result.mn = ( repeat ? 'OT' : 'OUT' ) + ( increment ? 'I' : 'D' ) + ( repeat ? 'R' : '' );
		            }

		            return result;
		        }

		        result.mn = 'NOP';
		        return result;
			}

			if ( prefix_cb ) {
				opcode = read_opcode_byte(bus, result.next++);
		        result.bytes.push(opcode);

		        // 00xxxxxx
		        if ( (opcode & 0xc0 ) == 0x00 ) {
		            // RLC r
		            // RLC (HL)
		            // RLC (IX + d)
		            // RLC (IY + d)
		            // * RLC (IY + d), r
		            // RL r
		            // RL (HL)
		            // RL (IX + d)
		            // RL (IY + d)
		            // * RL (IY + d), r
		            // RRC r
		            // RRC (HL)
		            // RRC (IX + d)
		            // RRC (IY + d)
		            // * RRC (IY + d), r
		            // RR r
		            // RR (HL)
		            // RR (IX + d)
		            // RR (IY + d)
		            // * RR (IY + d), r
		            // SLA r
		            // SLA (HL)
		            // SLA (IX + d)
		            // SLA (IY + d)
		            // * SLA (IY + d), r
		            // * SLL r
		            // * SLL (HL)
		            // * SLL (IX + d)
		            // * SLL (IY + d)                
		            // * SLL (IY + d), r
		            // SRA r
		            // SRA (HL)
		            // SRA (IX + d)
		            // SRA (IY + d)
		            // * SRA (IY + d), r
		            // SRL r
		            // SRL (HL)
		            // SRL (IX + d)
		            // SRL (IY + d)
		            // * SRL (IY + d), r

		            var cmd_shift = !!(opcode & 0x20);
		            var left = !(opcode & 0x08);
		            var carry = !(opcode & 0x10);
		            var r1 = opcode & 0x07;

		            var reg_name;
		            switch (r1) {
		            	case 0x00: reg_name = 'B'; break;
		            	case 0x01: reg_name = 'C'; break;
		            	case 0x02: reg_name = 'D'; break;
		            	case 0x03: reg_name = 'E'; break;
		            	case 0x04: reg_name = 'H'; break;
		            	case 0x05: reg_name = 'L'; break;
		            	case 0x06: reg_name = '(HL)'; break;
		            	case 0x07: reg_name = 'A'; break;
		            }

		            result.mn = ( cmd_shift ? 'S' : 'R' ) + ( left ? 'L' : 'R' );
		            if ( !cmd_shift & carry ) {
		            	result.mn  += 'C';
		            }

		            if ( cmd_shift ) {
		            	result.mn  += ( carry ? 'A' : 'L' );
		            }

		            result.mn += ' ';

		            if ( prefix_ix ) {
		            	result.mn  += '(IX + offs)';
		            	result.offs = offset;
		            }
		            else if ( prefix_iy ) {
		            	result.mn  += '(IY + offs)';
		            	result.offs = offset;
		            }
		            else {
		            	result.mn  += reg_name;
		            }

		            if (( prefix_ix || prefix_iy ) && r1 != 0x06 ) {
		            	result.mn  += ', ' + reg_name;
		            }

		            return result;
		        }

		        // 01xxxxxx
		        if ( (opcode & 0xc0 ) == 0x40 ) {
		            // BIT b, r
		            // BIT b, (HL)
		            // BIT b, (IX + d)
		            // BIT b, (IY + d)

		            var r_dst = opcode & 0x07;
		            var bit = (opcode >> 3) & 0x07;

		            var reg_name;
		            switch (r_dst) {
		            	case 0x00: reg_name = 'B'; break;
		            	case 0x01: reg_name = 'C'; break;
		            	case 0x02: reg_name = 'D'; break;
		            	case 0x03: reg_name = 'E'; break;
		            	case 0x04: reg_name = 'H'; break;
		            	case 0x05: reg_name = 'L'; break;
		            	case 0x06: reg_name = '(HL)'; break;
		            	case 0x07: reg_name = 'A'; break;
		            }

		            result.mn = 'BIT ' + bit + ', ';

		            if (prefix_ix) {
		            	result.mn += '(IX + offs)';
		            	result.offs = offset;
		            }
		            else if (prefix_iy) {
		            	result.mn += '(IY + offs)';
		            	result.offs = offset;
		            }
		            else {
		            	result.mn += reg_name;
		            }

		            if (( prefix_ix || prefix_iy ) && r_dst != 0x06 ) {
		            	result.mn  += ', ' + reg_name;
		            }

		            return result;
		        }

		        // 1xxxxxxx
		        if ( (opcode & 0x80 ) == 0x80 ) {
		            // SET b, r
		            // SET b, (HL)
		            // SET b, (IX + d)
		            // SET b, (IY + d)
		            // * SET b, (IX + d), r
		            // * SET b, (IY + d), r
		            // RES b, r
		            // RES b, (HL)
		            // RES b, (IX + d)
		            // RES b, (IY + d)
		            // * RES b, (IX + d), r
		            // * RES b, (IY + d), r

		            var r_dst = opcode & 0x07;
					var bit = (opcode >> 3) & 0x07;
					var cmd_set = !!(opcode & 0x40);

		            var reg_name;
		            switch (r_dst) {
		            	case 0x00: reg_name = 'B'; break;
		            	case 0x01: reg_name = 'C'; break;
		            	case 0x02: reg_name = 'D'; break;
		            	case 0x03: reg_name = 'E'; break;
		            	case 0x04: reg_name = 'H'; break;
		            	case 0x05: reg_name = 'L'; break;
		            	case 0x06: reg_name = '(HL)'; break;
		            	case 0x07: reg_name = 'A'; break;
		            }

		            result.mn = ( cmd_set ? 'SET ' : 'RES ' ) + bit + ', ';

		            if (prefix_ix) {
		            	result.mn += '(IX + offs)';
		            	result.offs = offset;
		            }
		            else if (prefix_iy) {
		            	result.mn += '(IY + offs)';
		            	result.offs = offset;
		            }
		            else {
		            	result.mn += reg_name;
		            }

		            if (( prefix_ix || prefix_iy ) && r_dst != 0x06 ) {
		            	result.mn  += ', ' + reg_name;
		            }

		            return result;
		        }

		        result.mn = 'NOP';
		        return result;
			}

		    if ( opcode == 0x00 ) {
		        result.mn = 'NOP';
		        return result;
		    }

		    // 01xxxxxx
		    if ( ( opcode & 0xc0 ) == 0x40 ) {
		        // LD r, r'
		        // LD r, (HL)
		        // LD (HL), r
		        // LD r, (IX + d)
		        // LD r, (IY + d)
		        // LD (IX + d), r
		        // LD (IY + d), r
		        // HALT
		        // + недокументированные

		        var r_dst = (opcode >> 3) & 0x07;
		        var r_src = opcode & 0x07;    

		        if (r_src == 0x06 && r_dst == 0x06) {
		            // HALT
		            result.mn = 'HALT';
		            return result;
		        }

		        var r_src_name;
		        switch (r_src) {
		            case 0x00: r_src_name = 'B'; break;
		            case 0x01: r_src_name = 'C'; break;
		            case 0x02: r_src_name = 'D'; break;
		            case 0x03: r_src_name = 'E'; break;
		            case 0x04: 
		                if (prefix_ix && r_dst != 0x06) {
		                    r_src_name = 'IX&h';
		                }
		                else if (prefix_iy && r_dst != 0x06) {
		                    r_src_name = 'IY&h';
		                }
		                else {
		                    r_src_name = 'H'; 
		                }
		                break;

		            case 0x05: 
		                if (prefix_ix && r_dst != 0x06) {
		                    r_src_name = 'IX&l';
		                }
		                else if (prefix_iy && r_dst != 0x06) {
		                    r_src_name = 'IY&l';
		                }
		                else {
		                    r_src_name = 'L'; 
		                }
		                break;

		            case 0x06:
		                var addr;
		                if (prefix_ix) {
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    r_src_name = '(IX + offs)';
		                }
		                else if (prefix_iy) {
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    r_src_name = '(IY + offs)';
		                }
		                else {
		                    r_src_name = '(HL)';
		                }
		                break;

		            case 0x07: r_src_name = 'A'; break;
		        }

		        var r_dst_name;
		        switch (r_dst) {
		            case 0x00: r_dst_name = 'B'; break;
		            case 0x01: r_dst_name = 'C'; break;
		            case 0x02: r_dst_name = 'D'; break;
		            case 0x03: r_dst_name = 'E'; break;
		            case 0x04: 
		                if (prefix_ix && r_src != 0x06) {
		                    r_dst_name = 'IX&h';
		                }
		                else if (prefix_iy && r_src != 0x06) {
		                    r_dst_name = 'IY&h';
		                }
		                else {
		                    r_dst_name = 'H'; 
		                }
		                break;

		            case 0x05: 
		                if (prefix_ix && r_src != 0x06) {
		                    r_dst_name = 'IX&l';
		                }
		                else if (prefix_iy && r_src != 0x06) {
		                    r_dst_name = 'IY&l';
		                }
		                else {
		                    r_dst_name = 'L'; 
		                }
		                break;

		            case 0x06: 
		                var addr;
		                if (prefix_ix) {
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    r_dst_name = '(IX + offs)';
		                }
		                else if (prefix_iy) {
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    r_dst_name = '(IY + offs)';
		                }
		                else {
		                    r_dst_name = '(HL)';
		                }
		                break;

		            case 0x07: r_dst_name = 'A'; break;
		        }            

		        result.mn = 'LD ' + r_dst_name + ', ' + r_src_name;

		        return result;
		    }

		    // 00xxx110
		    if ( ( opcode & 0xc7 ) == 0x06 ) {
		        // LD r, n
		        // LD (HL), n
		        // LD (IX + d), n
		        // LD (IY + d), n
		        // + недокументированные

		        var r_dst = (opcode >> 3) & 0x07;
		        var r_dst_name;
		        switch (r_dst) {
		            case 0x00: r_dst_name = 'B'; break;
		            case 0x01: r_dst_name = 'C'; break;
		            case 0x02: r_dst_name = 'D'; break;
		            case 0x03: r_dst_name = 'E'; break;
		            case 0x04: 
		                if (prefix_ix) {
		                    r_dst_name = 'IX&h';
		                }
		                else if (prefix_iy) {
		                    r_dst_name = 'IY&h';
		                }
		                else {
		                    r_dst_name = 'H';
		                }
		                break;

		            case 0x05: 
		                if (prefix_ix) {
		                    r_dst_name = 'IX&l';
		                }
		                else if (prefix_iy) {
		                    r_dst_name = 'IY&l';
		                }
		                else {
		                    r_dst_name = 'L';
		                }
		                break;

		            case 0x06: 
		                var addr;
		                if (prefix_ix) {
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    r_dst_name = '(IX + offs)';
		                }
		                else if (prefix_iy) {
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    r_dst_name = '(IY + offs)';
		                }
		                else {
		                    r_dst_name = '(HL)';
		                }                    
		                break;

		            case 0x07: r_dst_name = 'A'; break;
		        }

		        result.val8 = read_memory_byte(bus, result.next++);
		        result.bytes.push(result.val8);
		        result.mn = 'LD ' + r_dst_name + ', val8';

		        return result;
		    }

		    // 00xxx010
		    if ( (opcode & 0xc7 ) == 0x02 ) {
		        // LD A, (BC)
		        // LD A, (DE)
		        // LD A, (nn)
		        // LD HL, (nn)
		        // LD IX, (nn)
		        // LD IY, (nn)

		        // LD (BC), A
		        // LD (DE), A
		        // LD (nn), A
		        // LD (nn), HL
		        // LD (nn), IX
		        // LD (nn), IY

		        var to_reg = !!(opcode & 0x08);
		        var r_code = (opcode >> 4) & 0x03;

		        if (to_reg) {
		            switch (r_code) {
		                case 0x00: result.mn = 'LD A, (BC)'; break;
		                case 0x01: result.mn = 'LD A, (DE)'; break;
		                case 0x02: 
		                    // HL, (nn)
		                    var addr = read_memory_word(bus, result.next);
		                    result.next += 2;
		                    result.bytes.push(addr & 0xff);
		                    result.bytes.push(addr >> 8);

		                    if (prefix_ix) {
		                        result.mn = 'LD IX, (addr)';
		                    }
		                    else if (prefix_iy) {
		                        result.mn = 'LD IY, (addr)';
		                    }
		                    else {
		                        result.mn = 'LD HL, (addr)';
		                    }

		                    result.addr = addr;
		                    break;

		                case 0x03:
		                    // A, (nn)
		                    var addr = read_memory_word(bus, result.next);
		                    result.next += 2;
		                    result.bytes.push(addr & 0xff);
		                    result.bytes.push(addr >> 8);
		                    result.mn = 'LD A, (addr)';
		                    result.addr = addr;
		                    break;
		            }
		        }
		        else {
		            switch (r_code) {
		                case 0x00: result.mn = 'LD (BC), A'; break;
		                case 0x01: result.mn = 'LD (DE), A'; break;
		                case 0x02:
		                    // (nn), HL
		                    var addr = read_memory_word(bus, result.next);
		                    result.next += 2;
		                    result.bytes.push(addr & 0xff);
		                    result.bytes.push(addr >> 8);

		                    if (prefix_ix) {
		                        result.mn = 'LD (addr), IX'
		                    }
		                    else if (prefix_iy) {
		                        result.mn = 'LD (addr), IY'
		                    }
		                    else {
		                        result.mn = 'LD (addr), HL'
		                    }

		                    result.addr = addr;
		                    break;

		                case 0x03:
		                    // (nn), A
		                    var addr = read_memory_word(bus, result.next);
		                    result.next += 2;
		                    result.bytes.push(addr & 0xff);
		                    result.bytes.push(addr >> 8);

		                    result.mn = 'LD (addr), A';
		                    result.addr = addr;
		                    break;
		            }
		        }

		        return result;
		    }

		    // 00xx0001
		    if ( ( opcode & 0xcf ) == 0x01 ) {
		        // LD dd, nn
		        // LD IX, nn
		        // LD IY, nn

                var value = read_memory_word(bus, result.next);
                result.next += 2;
                result.bytes.push(value & 0xff);
                result.bytes.push(value >> 8);

		        var dd = (opcode >> 4) & 0x03;

		        var reg_name;
		        switch (dd) {
		            case 0x00: reg_name = 'BC'; break;
		            case 0x01: reg_name = 'DE'; break;
		            case 0x02: 
		                if (prefix_ix) {
		                    reg_name = 'IX';
		                }
		                else if (prefix_iy) {
		                    reg_name = 'IY'
		                }
		                else {
		                    reg_name = 'HL'
		                }
		                break;

		            case 0x03: reg_name = 'SP'; break;
		        }

		        result.mn = 'LD ' + reg_name + ', val16';
		        result.val16 = value;
		        return result;
		    }

		    // 11xx0x01
		    if ( (opcode & 0xcb) == 0xc1 ) {
		        // PUSH qq
		        // PUSH IX
		        // PUSH IY
		        // POP qq
		        // POP IX
		        // POP IY

		        var to_reg = !(opcode & 0x04);
		        var qq = (opcode >> 4) & 0x03;

		        var reg_name;
		        switch (qq) {
		            case 0x00: reg_name = 'BC'; break;
		            case 0x01: reg_name = 'DE'; break;
		            case 0x02:
		                if (prefix_ix) {
		                    reg_name = 'IX';
		                }
		                else if (prefix_iy) {
		                    reg_name = 'IY';
		                }
		                else {
		                    reg_name = 'HL';
		                }
		                break;

		            case 0x03: reg_name = 'AF'; break;
		        }

		        result.mn = ( to_reg ? 'POP ' : 'PUSH ' ) + reg_name;
		        return result;
		    }

		    // 11111001
		    if ( opcode == 0xf9 ) {
		        // LD SP, HL
		        // LD SP, IX
		        // LD SP, IY

		        if (prefix_ix) {
		            result.mn = 'LD SP, IX';
		        }
		        else if (prefix_iy) {
		            result.mn = 'LD SP, IY';
		        }
		        else {
		            result.mn = 'LD SP, HL';
		        }

		        return result;
		    }

		    if ( opcode == 0xeb ) {
		        // EX DE, HL
		        result.mn = 'EX DE, HL';
		        return result;
		    }

		    if ( opcode == 0x08 ) {
		        // EX AF, AF'
		        result.mn = 'EX AF, AF\'';
		        return result;
		    }

		    if ( opcode == 0xd9 ) {
		        // EXX
		        result.mn = 'EXX';
		        return result;
		    }

		    if ( opcode == 0xe3 ) {
		        // EX (SP), HL
		        // EX (SP), IX
		        // EX (SP), IY

		        if (prefix_ix) {
		            result.mn = 'EX (SP), IX';
		        }
		        else if (prefix_iy) {
		            result.mn = 'EX (SP), IY';
		        }
		        else {
		            result.mn = 'EX (SP), HL';
		        }

		        return result;
		    }

		    // 10xxxxxx and 11xxx110
		    if ( ( opcode & 0xc0 ) == 0x80 || ( opcode & 0xc7 ) == 0xc6 ) {
		        // ADD A, r
		        // ADD A, n
		        // ADD A, (HL)
		        // ADD A, (IX + d)
		        // ADD A, (IY + d)
		        // ADC A, r
		        // ADC A, n
		        // ADC A, (HL)
		        // ADC A, (IX + d)
		        // ADC A, (IY + d)
		        // SUB r
		        // SUB n
		        // SUB (HL)
		        // SUB (IX + d)
		        // SUB (IY + d)
		        // SBC A, r
		        // SBC A, n
		        // SBC A, (HL)
		        // SBC A, (IX + d)
		        // SBC A, (IY + d)
		        // AND r
		        // AND n
		        // AND (HL)
		        // AND (IX + d)
		        // AND (IY + d)
		        // OR r
		        // OR n
		        // OR (HL)
		        // OR (IX + d)
		        // OR (IY + d)
		        // XOR r
		        // XOR n
		        // XOR (HL)
		        // XOR (IX + d)
		        // XOR (IY + d)                
		        // CP r
		        // CP n
		        // CP (HL)
		        // CP (IX + d)
		        // CP (IY + d)
		        // + недокументированные

		        var operand;
		        var explicit_operand = !!(opcode & 0x40);
		        if (explicit_operand) {
		            operand = 'val8';
		            result.val8 = read_memory_byte(bus, result.next++); // n
		            result.bytes.push(result.val8);
		        }
		        else {
		            var r1 = opcode & 0x07;
		            switch (r1) {
		                case 0x00: operand = 'B'; break; // B
		                case 0x01: operand = 'C'; break; // C
		                case 0x02: operand = 'D'; break; // D
		                case 0x03: operand = 'E'; break; // E
		                case 0x04: 
		                    if (prefix_ix) {
		                        operand = 'IX&h'; // IXh
		                    }
		                    else if (prefix_iy) {
		                        operand = 'IY&h'; // IYh
		                    }
		                    else {
		                        operand = 'H'; // H
		                    }
		                    break;

		                case 0x05: 
		                    if (prefix_ix) {    
		                        operand = 'IX&l'; // IXl
		                    }
		                    else if (prefix_iy) {
		                        operand = 'IY&l'; // IYl
		                    }
		                    else {
		                        operand = 'L'; // L
		                    }
		                    break;

		                case 0x06:
		                    if (prefix_ix) {
		                        operand = '(IX + offs)'; // (IX + d)
		                        result.offs = read_memory_byte(bus, result.next++);
		                        result.bytes.push(result.offs);
		                    }
		                    else if (prefix_iy) {
		                        operand = '(IY + offs)'; // (IY + d)
		                        result.offs = read_memory_byte(bus, result.next++);
		                        result.bytes.push(result.offs);
		                    }
		                    else {
		                        operand = operand = '(HL)'; // (HL)
		                    }
		                    break;

		                case 0x07: operand = 'A'; break; // A
		            }
		        }

		        var logic = !!(opcode & 0x20);
		        if (logic) { // logic
		            var subcode = (opcode >> 3) & 0x03;

		            switch (subcode) {
		                case 0x00: result.mn = 'AND ' + operand; break;
		                case 0x01: result.mn = 'XOR ' + operand; break;
		                case 0x02: result.mn = 'OR ' + operand; break;
		                case 0x03: result.mn = 'CP ' + operand; break;
		            }
		        }
		        else { // arithmetic
		            var care_case = !!(opcode & 0x08);
		            var addition = !(opcode & 0x10);

		            if (addition) {
		                result.mn = ( care_case ? 'ADC A, ' : 'ADD A, ' ) + operand;
		            }
		            else {
		                result.mn = ( care_case ? 'SBC A, ' : 'SUB ' ) + operand;
		            }
		        }

		        return result;
		    }

		    // 00xxx10x
		    if ( (opcode & 0xc6 ) == 0x04 ) {
		        // INC r
		        // INC (HL)
		        // INC (IX + d)
		        // INC (IY + d)
		        // DEC r
		        // DEC (HL)
		        // DEC (IX + d)
		        // DEC (IY + d)
		        // + недокументированные


		        var r1 = (opcode >> 3) & 0x07;
		        var cmd_inc = !(opcode & 0x01);

		        var reg_name;
		        switch (r1) {
		            case 0x00: reg_name = 'B'; break;
		            case 0x01: reg_name = 'C'; break;
		            case 0x02: reg_name = 'D'; break;
		            case 0x03: reg_name = 'E'; break;
		            case 0x04:
		                if (prefix_ix) {
		                    reg_name = 'IX&h';
		                }
		                else if (prefix_iy) {
		                    reg_name = 'IY&h';
		                }
		                else {
		                    reg_name = 'H';
		                }
		                break;

		            case 0x05:
		                if (prefix_ix) {
		                    reg_name = 'IX&l';
		                }
		                else if (prefix_iy) {
		                    reg_name = 'IY&l';
		                }
		                else {
		                    reg_name = 'L';
		                }
		                break;   

		            case 0x06:
		                if (prefix_ix) {
		                    // (IX + d)
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    reg_name = '(IX + offs)';
		                }
		                else if (prefix_iy) {
		                    // (IY + d)
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    reg_name = '(IY + offs)';
		                }
		                else {
		                    // (HL)
		                    reg_name = '(HL)';
		                }
		                break;

		            case 0x07: reg_name = 'A'; break;
		        }

		        result.mn = ( cmd_inc ? 'INC ' : 'DEC ' ) + reg_name;
		        return result;
		    }

		    // 1111x011
		    if ( (opcode & 0xf7 ) == 0xf3 ) {
		        // DI
		        // EI

		        var allow_int = !!(opcode & 0x08);
		        result.mn = allow_int ? 'EI' : 'DI';
		        return result;
		    }

		    // 00100111
		    if ( opcode == 0x27 ) {
		        // DAA
		        result.mn = 'DAA';
		        return result;
		    }

		    // 00101111
		    if ( opcode == 0x2f ) {
		        // CPL

		        result.mn = 'CPL';
		        return result;
		    }

		    // 00111111
		    if ( opcode == 0x3f ) {
		        // CCF

		        result.mn = 'CCF';
		        return result;
		    }

		    // 00110111
		    if ( opcode == 0x37 ) {
		        // SCF

		        result.mn = 'SCF';
		        return result;
		    }

		    // 00xx1001
		    if ( ( opcode & 0xcf ) == 0x09 ) {
		        // ADD HL, ss
		        // ADD IX, pp
		        // ADD IY, rr

		        var ss = (opcode >> 4) & 0x03;
		        var operand;
		        switch (ss) {
		            case 0x00: operand = 'BC'; break; // BC
		            case 0x01: operand = 'DE'; break; // DE
		            case 0x02:
		                if (prefix_ix) {
		                    operand = 'IX'; // IX
		                }
		                else if (prefix_iy) {
		                    operand = 'IY'; // IY
		                }
		                else {
		                    operand = 'HL'; // HL
		                }
		                break;

		            case 0x03: operand = 'SP'; break; // SP
		        }

		        if (prefix_ix) {
		            result.mn = 'ADD IX, ' + operand;
		        }
		        else if (prefix_iy) {
		            result.mn = 'ADD IY, ' + operand;
		        }
		        else {
		            result.mn = 'ADD HL, ' + operand;
		        }

		        return result;
		    }

		    // 00xxx011
		    if ( (opcode & 0xc7 ) == 0x03 ) {
		        // INC ss
		        // INC IX
		        // INC IY
		        // DEC ss
		        // DEC IX
		        // DEC IY

		        var cmd_inc = !(opcode & 0x08);
		        var ss = (opcode >> 4) & 0x03;

		        var reg_name;
		        switch (ss) {
		            case 0x00: reg_name = 'BC'; break; // BC
		            case 0x01: reg_name = 'DE'; break; // DE
		            case 0x02:
		                if (prefix_ix) {
		                    reg_name = 'IX'; // IX
		                }
		                else if (prefix_iy) {
		                    reg_name = 'IY'; // IY
		                }
		                else {
		                    reg_name = 'HL'; // HL
		                }
		                break;

		            case 0x03: reg_name = 'SP'; break; // SP
		        }

		        result.mn = ( cmd_inc ? 'INC ' : 'DEC ' ) + reg_name;
		        return result;
		    }

		    // 000xx111
		    if ( (opcode & 0xe7 ) == 0x07 ) {
		        // RLCA
		        // RLA
		        // RRCA
		        // RRA

		        var left = !(opcode & 0x08);
		        var carry = !(opcode & 0x10);

		        result.mn = 'R' + ( left ? 'L' : 'R' ) + ( carry ? 'C' : '' ) + 'A';
		        return result;
		    }

		    // 11000011
		    if ( opcode == 0xc3 ) {
		        // JP nn

                result.addr = read_memory_word(bus, result.next);
                result.next += 2;
                result.bytes.push(addr & 0xff);
                result.bytes.push(addr >> 8);
		        result.mn = 'JP addr';
		        return result;
		    }

		    // 11xxx010
		    if ( (opcode & 0xc7 ) == 0xc2 ) {
		        // JP cc, nn

		        var condition_code = (opcode >> 3) & 0x07;

		        var condition;
		        switch (condition_code) {
		            case 0x00: condition = 'NZ'; break; // NZ
		            case 0x01: condition = 'Z'; break; // Z
		            case 0x02: condition = 'NC'; break; // NC
		            case 0x03: condition = 'C'; break; // C
		            case 0x04: condition = 'PO'; break; // PO
		            case 0x05: condition = 'PE'; break; // PE
		            case 0x06: condition = 'P'; break; // P
		            case 0x07: condition = 'M'; break; // M
		        }

                result.addr = read_memory_word(bus, result.next);
                result.next += 2;
                result.bytes.push(addr & 0xff);
                result.bytes.push(addr >> 8);
		        result.mn = 'JP ' + condition + ', addr';
		        return result;
		    }

		    // 00xxx000 where xxx >= 010
		    if ( ( opcode & 0xc7 ) == 0x00 && ( opcode & 0x38 ) >= 0x10 ) {
		        // JR e
		        // JR C, e
		        // JR NC, e
		        // JR Z, e
		        // JR NZ, e
		        // DJNZ e

		        var condition_code = (opcode >> 3) & 0x07;

		        var condition;
		        switch (condition_code) {
		            case 0x02: result.mn = 'DJNZ addr'; break;
		            case 0x03: result.mn = 'JR addr'; break; // JR e
		            case 0x04: result.mn = 'JR NZ, addr'; break; // JR NZ, e
		            case 0x05: result.mn = 'JR Z, addr'; break; // JR Z, e
		            case 0x06: result.mn = 'JR NC, addr'; break; // JR NC, e
		            case 0x07: result.mn = 'JR C, addr'; break; // JR C, e
		        }

		        var offset = read_memory_byte(bus, result.next++);
		        result.bytes.push(offset);

		        result.addr = result.next;
		        if ( offset & 0x80 ) {
		            result.addr -= ((offset ^ 0xff) + 1);
		        }
		        else {
		            result.addr += offset;
		        }

		        return result;
		    }

		    // 11101001
		    if ( opcode == 0xe9 ) {
		        // JP (HL)
		        // JP (IX)
		        // JP (IY)
		        // * это не косвенная адресация, читать мнемонику без скобок!

		        if (prefix_ix) {
		            result.mn = 'JP (IX)';
		        }
		        else if (prefix_iy) {
		            result.mn = 'JP (IY)';
		        }
		        else {
		            result.mn = 'JP (HL)';
		        }

		        return result;
		    }

		    // 11001101
		    if ( opcode == 0xcd ) {
		        // CALL nn

                result.addr = read_memory_word(bus, result.next);
                result.next += 2;
                result.bytes.push(result.addr & 0xff);
                result.bytes.push(result.addr >> 8);
		        result.mn = 'CALL addr';
		        return result;
		    }

		    // 11xxx100
		    if ( ( opcode & 0xc7 ) == 0xc4 ) {
		        // CALL cc, nn

		        var condition_code = (opcode >> 3) & 0x07;

		        var condition;
		        switch (condition_code) {
		            case 0x00: condition = 'NZ'; break; // NZ
		            case 0x01: condition = 'Z'; break; // Z
		            case 0x02: condition = 'NC'; break; // NC
		            case 0x03: condition = 'C'; break; // C
		            case 0x04: condition = 'PO'; break; // PO
		            case 0x05: condition = 'PE'; break; // PE
		            case 0x06: condition = 'P'; break; // P
		            case 0x07: condition = 'M'; break; // M
		        }

                result.addr = read_memory_word(bus, result.next);
                result.next += 2;
                result.bytes.push(result.addr & 0xff);
                result.bytes.push(result.addr >> 8);
		        result.mn = 'CALL ' + condition + ', addr';
		        return result;
		    }

		    // 11001001
		    if ( opcode == 0xc9 ) {
		        // RET

		        result.mn = 'RET';
		        return result;
		    }

		    // 11xxx000
		    if ( ( opcode & 0xc7 ) == 0xc0 ) {
		        // RET cc

		        var condition_code = (opcode >> 3) & 0x07;

		        var condition;
		        switch (condition_code) {
		            case 0x00: condition = 'NZ'; break; // NZ
		            case 0x01: condition = 'Z'; break; // Z
		            case 0x02: condition = 'NC'; break; // NC
		            case 0x03: condition = 'C'; break; // C
		            case 0x04: condition = 'PO'; break; // PO
		            case 0x05: condition = 'PE'; break; // PE
		            case 0x06: condition = 'P'; break; // P
		            case 0x07: condition = 'M'; break; // M
		        }

		        result.mn = 'RET ' + condition;
		        return result;
		    }

		    // 11xxx111
		    if ( (opcode & 0xc7 ) == 0xc7 ) {
		        // RST p

		        var rst_code = (opcode >> 3) & 0x07;
		        var addr = rst_code << 3; // code * 8

		        result.mn = 'RST addr';
		        result.addr = addr;
		        return result;
		    }

		    // 1101x011
		    if ( ( opcode & 0xf7 ) == 0xd3 ) {
		        // IN A, (n)
		        // OUT (n), A

		        var port_low = read_memory_byte(bus, result.next++);

		        result.bytes.push(port_low);
		        result.port = port_low;

		        var cmd_in = !!(opcode & 0x08);
		        if (cmd_in) {
		            // IN
		            result.mn = 'IN A, (port)'
		        }
		        else {
		            // OUT
		            result.mn = 'OUT (port), A'
		        }

		        return result;
		    } 

		    result.mn = 'UNKNOWN';
		    return result;
		}		
	})();
</script>