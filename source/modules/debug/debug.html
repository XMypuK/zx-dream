<style>
	.debug-toolbar {
		background-color: #cccccc;
		border: 1px solid #444444;
		border-bottom: none;
	}

	.zxdebug-registers {
		font-family: Courier New, monospace; 
		font-size: 14px;
	}

	.zxdebug-registers td, .zxdebug-registers th {
		text-align: center;
	}

	.zxdebug-registers .changed {
		color: #ff0000;
	}

	.zxdebug-trace {
		display: inline-block;
		padding: 0px 0px;
		width: 33%;
		vertical-align: top;

		font-family: Courier New, monospace; 
		font-size: 14px;

		border: 1px solid #444444;
		border-top: none;
		box-sizing: border-box;
		-moz-box-sizing: border-box;
		-webkit-box-sizing: border-box;
	}

	.zxdebug-trace .debug-toolbar {
		border: none;
		border-bottom: 1px solid #444444;
	}

	.zxdebug-trace .dasm-line {
		padding: 0px 5px;
	}

	.zxdebug-trace .dasm-line-active {
		padding: 0px 5px;
		background-color: #444444;
		color: #ffffff;
	}

	.zxdebug-trace .addr {
		width: 50px;
		display: inline-block;
	}

	.zxdebug-trace .bytes {
		width: 80px;
		display: inline-block;
	}

	.zxdebug-memory {
		display: inline-block;
		padding: 0px 0px;
		width: 34%;
		vertical-align: top;

		font-family: Courier New, monospace; 
		font-size: 14px;

		border: 1px solid #444444;
		border-left: none;
		border-top: none;
		box-sizing: border-box;
		-moz-box-sizing: border-box;
		-webkit-box-sizing: border-box;

		overflow-x: auto;
	}

	.zxdebug-memory .debug-toolbar {
		border: none;
		border-bottom: 1px solid #444444;
	}

	.zxdebug-memory .mem-line {
		padding: 0px 5px;
		white-space: nowrap;
	}

	.zxdebug-memory .addr {
		width: 50px;
		display: inline-block;
	}

	.zxdebug-watch {
		display: inline-block;
		padding: 0px 0px;
		width: 33%;
		vertical-align: top;
		font-family: Courier New, monospace; 
		font-size: 14px;

		border: 1px solid #444444;
		border-left: none;
		border-top: none;
		box-sizing: border-box;
		-moz-box-sizing: border-box;
		-webkit-box-sizing: border-box;
	}

	.zxdebug-watch .debug-toolbar {
		border: none;
		border-bottom: 1px solid #444444;
	}
</style>

<template id="toolbar">
	<div class="debug-toolbar">
		<input id="zxdebug_cb_hex" type="checkbox" class="debug-command" data-command="toggle-hex" checked /><label for="zxdebug_cb_hex">hex</label>
		<input id="zxdebug_cb_enable_hotkeys" type="checkbox" class="debug-command" data-command="enable-hotkeys" /><label for="zxdebug_cb_enable_hotkeys">enable hotkeys</label>
	</div>
</template>

<template id="registers">
	<div class="zxdebug-registers">
		<table border="1" style="border-collapse: collapse;" cellpadding="2" width="100%">
			<tr>
				<th colspan="2">AF</th>
				<th colspan="2">BC</th>
				<th colspan="2">DE</th>
				<th colspan="2">HL</th>
				<th colspan="2">IX</th>
				<th colspan="2">IY</th>
				<th colspan="2">PC</th>
				<th colspan="2">SP</th>
				<th colspan="2">AF'</th>
				<th colspan="2">BC'</th>
				<th colspan="2">DE'</th>
				<th colspan="2">HL'</th>
			</tr>
			<tr>
				<td id="zxdebug_r_af" colspan="2"></td>
				<td id="zxdebug_r_bc" colspan="2"></td>
				<td id="zxdebug_r_de" colspan="2"></td>
				<td id="zxdebug_r_hl" colspan="2"></td>
				<td id="zxdebug_r_ix" colspan="2"></td>
				<td id="zxdebug_r_iy" colspan="2"></td>
				<td id="zxdebug_r_pc" colspan="2"></td>
				<td id="zxdebug_r_sp" colspan="2"></td>
				<td id="zxdebug_r_af_" colspan="2"></td>
				<td id="zxdebug_r_bc_" colspan="2"></td>
				<td id="zxdebug_r_de_" colspan="2"></td>
				<td id="zxdebug_r_hl_" colspan="2"></td>
			</tr>
			<tr>
				<td id="zxdebug_r_a"></td>
				<td id="zxdebug_r_f"></td>
				<td id="zxdebug_r_b"></td>
				<td id="zxdebug_r_c"></td>
				<td id="zxdebug_r_d"></td>
				<td id="zxdebug_r_e"></td>
				<td id="zxdebug_r_h"></td>
				<td id="zxdebug_r_l"></td>
				<td rowspan="2" colspan="8">
					<table width="100%">
						<tr>
							<td id="zxdebug_f_s" width="16%"></td>
							<td id="zxdebug_f_z" width="16%"></td>
							<td id="zxdebug_f_h" width="16%"></td>
							<td id="zxdebug_f_p" width="16%"></td>
							<td id="zxdebug_f_n" width="16%"></td>
							<td id="zxdebug_f_c" width="16%"></td>
						</tr>
						<tr>
							<th>S</th>
							<th>Z</th>
							<th>H</th>
							<th>P/V</th>
							<th>N</th>
							<th>C</th>
						</tr>							
					</table>						
				</td>
				<td colspan="2"></td>
				<td id="zxdebug_iff" colspan="2"></td>
				<td id="zxdebug_imf" colspan="2"></td>
				<td id="zxdebug_r_i"></td>
				<td id="zxdebug_r_r"></td>
			</tr>
			<tr>
				<th width="4.16%">A</th>
				<th width="4.16%">F</th>
				<th width="4.16%">B</th>
				<th width="4.16%">C</th>
				<th width="4.16%">D</th>
				<th width="4.16%">E</th>
				<th width="4.16%">H</th>
				<th width="4.16%">L</th>
				<th width="8.32%" colspan="2"></th>
				<th width="8.32%" colspan="2">IFF</th>
				<th width="8.32%" colspan="2">IMF</th>
				<th width="4.16%">I</th>
				<th width="4.16%">R</th>
			</tr>
		</table>
	</div>
</template>

<template id="trace-block">
	<div class="zxdebug-trace">
		<div class="debug-toolbar">
			<button class="debug-command" data-command="step-in">Si</button>
			<button class="debug-command" data-command="step-out">So</button>
			<button class="debug-command" data-command="step-to">St</button>
			<button class="debug-command" data-command="toggle-bp">BP</button>
			<button class="debug-command" data-command="run">Run</button>
		</div>
		<div id="zxdebug_dasm"></div>
	</div>
</template>

<template id="memory-block">
	<div class="zxdebug-memory">
		<div class="debug-toolbar">
			<button class="debug-command" data-command="mem-go-to">G</button>
			<button class="debug-command" data-command="mem-add-8h">+8</button>
			<button class="debug-command" data-command="mem-sub-8h">-8</button>
			<button class="debug-command" data-command="mem-add-80h">+80h</button>
			<button class="debug-command" data-command="mem-sub-80h">-80h</button>
			<input type="checkbox" id="zxdebug_cb_words" class="debug-command" data-command="toggle-words" /><label for="zxdebug_cb_words">words</label>		
		</div>
		<div id="zxdebug_memory"></div>
	</div>
</template>

<template id="watch-block">
	<div class="zxdebug-watch">
		<div class="debug-toolbar">
			<button class="debug-command" data-command="add-watch">Add</button>
			<button class="debug-command" data-command="remove-watches">Remove</button>
		</div>
		<div id="zxdebug_watch"></div>
	</div>
</template>

<template id="watch-item-block">
	<div class="zxdebug-watch-item">
		<label>
			<input type="checkbox" class="watch-item-selected" />
			<span class="watch-item-address"></span>
			<span class="watch-item-name"></span>
			<span class="watch-item-value"></span>
		<label>
	</div>
</template>

<template id="watch-add-dialog">
	<div class="zxdebug-watch-add-dialog">
		<table>
			<tbody>
				<tr>
					<td>Name:</td>
					<td><input type="text" class="watch-name"</td>
				</tr>
				<tr>
					<td>Address:</td>
					<td><input type="text" class="watch-address"></td>
				</tr>
				<tr>
					<td>Length:</td>
					<td>
						<select class="watch-length">
							<option value="byte">byte</option>
							<option value="word">word</option>
						</select>
					</td>
				</tr>
			</tbody>
		</table>
	</div>
</template>

<script type="text/javascript">
	var debugCommandManager = new (function() {
		var self = this;

		var availableCommands = []; // [ "commandName1", "commandName2", ... ]
		var hotKeyCommands = {}; // { keyCode: "commandName", ... }
		var commandHandlers = {}; // { "command": [ function(){}, function(){}, ... ], ... }
		var enableHotkeys = false;

		$(document).on('keydown', function ( event ) {
			if ( enableHotkeys && hotKeyCommands[event.which] !== undefined ) {
				self.doCommand(hotKeyCommands[event.which]);
			}
		});

		$(document).on('click', function ( event ) {
			$target = $(event.target);
			if ( $target.hasClass('debug-command') ) {
				var command = $target.attr('data-command');
				if ( command ) {
					self.doCommand(command);
				}
			}
		});

		this.enableHotkeys = function (value) {
			if ( value !== undefined ) {
				enableHotkeys = !!value;
			}
			else {
				return enableHotkeys;
			}
		};

		this.onCommand = function ( command, handler ) {
			commandHandlers[command] = commandHandlers[command] || [];
			commandHandlers[command].push(handler);
		}

		this.doCommand = function ( command ) {
			if ( $.grep(availableCommands, function ( cmd ) { return cmd === command; }).length > 0 ) {
				var handlers = commandHandlers[command];
				if ( handlers ) {
					$.each(handlers, function ( i, handler ) {
						handler();
					});
				}
			}
		}

		this.enableCommand = function ( /* command1, command2, ... */ ) {
			for ( var argIndex = 0; argIndex < arguments.length; argIndex++ ) {
				var command = arguments[argIndex];

				if ( $.grep(availableCommands, function ( cmd ) { return cmd === command; }).length == 0 ) {
					availableCommands.push(command);

					$('.debug-command[data-command="' + command + '"]')
						.prop('disabled', false);
				}
			}
		}

		this.disableCommand = function ( /* command1, command2, ... */ ) {
			for ( var argIndex = 0; argIndex < arguments.length; argIndex++ ) {
				var command = arguments[argIndex];			
	
				if ( $.grep(availableCommands, function ( cmd ) { return cmd === command; }).length > 0 ) {
					for ( var i = 0; i < availableCommands.length; ) {
						if ( availableCommands[i] === command ) {
							availableCommands.splice(i, 1);
						}
						else {
							i++;
						}
					}

					$('.debug-command[data-command="' + command + '"]')
						.prop('disabled', true);
				}
			}
		}

		this.attachHotKey = function ( keyCode, command ) {
			hotKeyCommands[keyCode] = command;
		}
	})();

	var zxdebug = new (function() {
		// public
		this.debug = debug;

		// private
		var self = this;
		var hex = true;
		var break_points = [];
		var running = false;
		var break_request = false;
		var settings = null;
		var bus = null;
		var cpu = null;
		var display = null;

		function debug( container, _cpu, _bus, _display, _settings ) {
			settings = _settings;
			cpu = _cpu;
			bus = _bus;
			display = _display;

			$("<?=toolbar?>")
				.appendTo(container);

			self.registers = new RegistersBlock(container, cpu);
			self.disasm = new DisasmBlock(container, cpu, bus);
			self.memory = new MemoryBlock(container, bus);
			self.watches = new WatchBlock(container, bus);
			var eClear = document.createElement('div');
			eClear.style.clear = "both";
			container.appendChild(eClear);

			self.registers.update(true);
			self.disasm.update();
			self.memory.update();
			self.watches.update();
		}

		var cmds = debugCommandManager;
		cmds.attachHotKey(0x49, 'step-in');
		cmds.attachHotKey(0x4f, 'step-out');
		cmds.attachHotKey(0x54, 'step-to');
		cmds.attachHotKey(0x42, 'toggle-bp');
		cmds.attachHotKey(0x52, 'run');
		cmds.attachHotKey(0x4d, 'mem-go-to');
		cmds.attachHotKey(0x2b, 'mem-add-8h');
		cmds.attachHotKey(0x6b, 'mem-add-8h');
		cmds.attachHotKey(0x2d, 'mem-sub-8h');
		cmds.attachHotKey(0x6d, 'mem-sub-8h');
		cmds.attachHotKey(0x22, 'mem-add-80h');
		cmds.attachHotKey(0x21, 'mem-sub-80h');
		cmds.attachHotKey(0x48, 'toggle-hex');
		cmds.attachHotKey(0x57, 'toggle-words');

		cmds.onCommand('step-in', step_in);
		cmds.onCommand('step-out', step_out);
		cmds.onCommand('step-to', step_to);
		cmds.onCommand('toggle-bp', toggle_break_point);
		cmds.onCommand('run', run_break);
		cmds.onCommand('mem-go-to', function() { self.memory.change_memory_address(); });
		cmds.onCommand('mem-add-8h', function() { self.memory.shift_memory_address(8); });
		cmds.onCommand('mem-sub-8h', function() { self.memory.shift_memory_address(-8); });
		cmds.onCommand('mem-add-80h', function() { self.memory.shift_memory_address(0x80); });
		cmds.onCommand('mem-sub-80h', function() { self.memory.shift_memory_address(-0x80); });
		cmds.onCommand('toggle-hex', updateNumberFormat);
		cmds.onCommand('toggle-words', function() { self.memory.display_words($('#zxdebug_cb_words').is(':checked')); });
		cmds.onCommand('enable-hotkeys', function() { cmds.enableHotkeys($('#zxdebug_cb_enable_hotkeys').is(':checked')); });
		cmds.onCommand('add-watch', function() { self.watches.addWatch(); });
		cmds.onCommand('remove-watches', function () { self.watches.removeWatches(); });

		cmds.enableCommand(
			'toggle-hex',
			'step-in', 
			'step-out', 
			'step-to', 
			'toggle-bp', 
			'run',
			'mem-go-to',
			'mem-add-8h',
			'mem-sub-8h',
			'mem-add-80h',
			'mem-sub-80h',
			'toggle-words',
			'enable-hotkeys',
			'add-watch',
			'remove-watches');

		function updateNumberFormat() {
			hex = $('#zxdebug_cb_hex').is(':checked');
			self.registers.update(false);
			self.disasm.update();
			self.memory.update();
			self.watches.update();
		}

		function step_in() {
			cmds.disableCommand(
				'toggle-hex',
				'step-in', 
				'step-out', 
				'step-to', 
				'mem-go-to',
				'mem-add-8h',
				'mem-sub-8h',
				'mem-add-80h',
				'mem-sub-80h',
				'toggle-words',
				'add-watch',
				'remove-watches');

			var state = cpu.get_state();
			var cmd = disasm_instruction(bus, state.pc);
			if ( /^(JP|JR|DJNZ|CALL|RST)/.test(cmd.mn) ) {
				// прыжки и вызовы могут передать управление по заданному адресу
				if ( cmd.addr !== undefined ) {
					run_to(cmd.next, cmd.addr);
				}
				else {
					var addr;
					if ( /HL/.test(cmd.mn) ) {
						addr = state.hl;
					}
					else if ( /IX/.test(cmd.mn) ) {
						addr = state.ix;
					}
					else if ( /IY/.test(cmd.mn) ) {
						addr = state.iy;
					}
					else {
						throw Error('Unknown control command');
					}

					run_to(cmd.next, addr);
				}
			}
			else if ( /^RET/.test(cmd.mn) ) {
				// команды RET... может передать управление как следующей команде, так и по адресу в стеке
                var addr = read_memory_word(bus, state.sp);
				run_to(cmd.next, addr);
			}
			else if ( /^(HALT|(LD|CP|IN|OT)[ID]R)/.test(cmd.mn) ) {
				// блочные команды и команда HALT могут откинуть PC на начало команды
				run_to(cmd.next, state.pc);
			}
			else {
				run_to(cmd.next);
			}			
		}

		function step_out() {
			cmds.disableCommand(
				'toggle-hex',
				'step-in', 
				'step-out', 
				'step-to', 
				'mem-go-to',
				'mem-add-8h',
				'mem-sub-8h',
				'mem-add-80h',
				'mem-sub-80h',
				'toggle-words',
				'add-watch',
				'remove-watches');

			var state = cpu.get_state();
			var cmd = disasm_instruction(bus, state.pc);
			if ( /^(JP|JR|DJNZ)/.test(cmd.mn) ) {
				if ( cmd.addr !== undefined ) {
					run_to(cmd.next, cmd.addr);
				}
				else {
					var addr;
					if ( /HL/.test(cmd.mn) ) {
						addr = state.hl;
					}
					else if ( /IX/.test(cmd.mn) ) {
						addr = state.ix;
					}
					else if ( /IY/.test(cmd.mn) ) {
						addr = state.iy;
					}
					else {
						throw Error('Unknown control command');
					}

					run_to(cmd.next, addr);
				}
			}
			else if ( /^RET/.test(cmd.mn) ) {
                var addr = read_memory_word(bus, state.sp);
				run_to(cmd.next, addr);
			}
			else {
				run_to(cmd.next);
			}
		}

		function step_to() {
			var str_address = prompt('Введите адрес точки останова:', '');
			if ( str_address != null ) {
				str_address = str_address.replace(/^\s+|\s+$/g, '');
				var radix = 10;
				if (str_address.length && str_address.charAt(str_address.length - 1).toLowerCase() == 'h') {
					radix = 16;
				}
				if (str_address.length >= 2 & str_address.charAt(0) == '0' && str_address.charAt(1).toLowerCase() == 'x') {
					radix = 16;
				}
				var addr = parseInt(str_address, radix);
				if (!isNaN(addr)) {
					self.toolbar.disable();
					run_to(addr);
				}
			}
		}

		function run_break() {
			if ( running ) {
				break_request = true;
			}
			else {
				cmds.disableCommand(
					'toggle-hex',
					'step-in', 
					'step-out', 
					'step-to', 
					'mem-go-to',
					'mem-add-8h',
					'mem-sub-8h',
					'mem-add-80h',
					'mem-sub-80h',
					'toggle-words',
					'add-watch',
					'remove-watches');

				run_to(-1);
			}
		}

		function toggle_break_point() {
			var str_address = prompt('Введите адрес точки останова:', '');
			if ( str_address != null ) {
				str_address = str_address.replace(/^\s+|\s+$/g, '');
				var radix = 10;
				if (str_address.length && str_address.charAt(str_address.length - 1).toLowerCase() == 'h') {
					radix = 16;
				}
				if (str_address.length >= 2 & str_address.charAt(0) == '0' && str_address.charAt(1).toLowerCase() == 'x') {
					radix = 16;
				}
				var addr = parseInt(str_address, radix);
				if (!isNaN(addr)) {
					var deleted = false;
					for (var i = 0; i < break_points.length; i++) {
						if ( break_points[ i ] == addr ) {
							break_points.splice(i, 1);
							deleted = true;
							alert('Точка останова удалена');
							break;
						}
					}

					if (!deleted) {
						break_points.push(addr);
						alert('Точка останова добавлена');
					}
				}
			}
		}


		function run_to(address1, address2) {
			running = true;

			var tstatesPerIntrq = settings.get_turboMode() ? settings.get_tstatesPerIntrq() : settings.get_tstatesPerIntrqTurbo();

			while (true) {
				if ( cpu.get_tstates() >= tstatesPerIntrq ) {
					bus.var_write('intrq');
					cpu.set_tstates(0);
					setTimeout(function() { run_to(address1, address2); }, 0);
					return;
				}

				cpu.process();

				var state = cpu.get_state();
				var bp = ( state.pc == address1 ) || ( state.pc == address2 );
				if (!bp) {
					for (var i = 0; i < break_points.length; i++) {
						if ( state.pc == break_points[i] ) {
							bp = true;
							break;
						}
					}
				}

				if ( bp || break_request ) {
					display.force_redraw();

					cmds.enableCommand(
						'toggle-hex',
						'step-in', 
						'step-out', 
						'step-to', 
						'toggle-bp',
						'run',
						'mem-go-to',
						'mem-add-8h',
						'mem-sub-8h',
						'mem-add-80h',
						'mem-sub-80h',
						'toggle-words',
						'add-watch',
						'remove-watches');

					self.registers.update(true);
					self.disasm.update();
					self.memory.update();
					running = false;
					break_request = false;
					return;
				}
			}
		}

		function RegistersBlock(container, cpu) {
			// public
			this.update = update;

			// private
			$("<?=registers?>")
				.appendTo(container);

			var r_pc = document.getElementById('zxdebug_r_pc');
			var r_sp = document.getElementById('zxdebug_r_sp');
			var r_ix = document.getElementById('zxdebug_r_ix');
			var r_iy = document.getElementById('zxdebug_r_iy');
			var r_hl = document.getElementById('zxdebug_r_hl');
			var r_h  = document.getElementById('zxdebug_r_h');
			var r_l  = document.getElementById('zxdebug_r_l');
			var r_de = document.getElementById('zxdebug_r_de');
			var r_d  = document.getElementById('zxdebug_r_d');
			var r_e  = document.getElementById('zxdebug_r_e');
			var r_bc = document.getElementById('zxdebug_r_bc');
			var r_b  = document.getElementById('zxdebug_r_b');
			var r_c  = document.getElementById('zxdebug_r_c');
			var r_af = document.getElementById('zxdebug_r_af');
			var r_a  = document.getElementById('zxdebug_r_a');
			var r_f  = document.getElementById('zxdebug_r_f');
			var r_hl_= document.getElementById('zxdebug_r_hl_');
			var r_de_= document.getElementById('zxdebug_r_de_');
			var r_bc_= document.getElementById('zxdebug_r_bc_');
			var r_af_= document.getElementById('zxdebug_r_af_');
			var r_i  = document.getElementById('zxdebug_r_i');
			var r_r  = document.getElementById('zxdebug_r_r');
			var f_s  = document.getElementById('zxdebug_f_s');
			var f_z  = document.getElementById('zxdebug_f_z');
			var f_h  = document.getElementById('zxdebug_f_h');
			var f_p  = document.getElementById('zxdebug_f_p');
			var f_n  = document.getElementById('zxdebug_f_n');
			var f_c  = document.getElementById('zxdebug_f_c');
			var iff  = document.getElementById('zxdebug_iff');
			var imf  = document.getElementById('zxdebug_imf');

			var last_state = cpu.get_state();

			function update( update_styles ) {
				var state = cpu.get_state();

				// значения
				r_pc.innerHTML = word_to_string(state.pc);
				r_sp.innerHTML = word_to_string(state.sp);
				r_ix.innerHTML = word_to_string(state.ix);
				r_iy.innerHTML = word_to_string(state.iy);

				r_hl.innerHTML = word_to_string(state.hl);
				r_h.innerHTML = byte_to_string(state.hl >> 8);
				r_l.innerHTML = byte_to_string(state.hl & 0xff);

				r_de.innerHTML = word_to_string(state.de);
				r_d.innerHTML = byte_to_string(state.de >> 8);
				r_e.innerHTML = byte_to_string(state.de & 0xff);

				r_bc.innerHTML = word_to_string(state.bc);
				r_b.innerHTML = byte_to_string(state.bc >> 8);
				r_c.innerHTML = byte_to_string(state.bc & 0xff);

				r_af.innerHTML = word_to_string(state.af);
				r_a.innerHTML = byte_to_string(state.af >> 8);
				r_f.innerHTML = byte_to_string(state.af & 0xff);

				r_hl_.innerHTML = word_to_string(state.hl_);
				r_de_.innerHTML = word_to_string(state.de_);
				r_bc_.innerHTML = word_to_string(state.bc_);
				r_af_.innerHTML = word_to_string(state.af_);

				r_i.innerHTML = byte_to_string(state.i);
				r_r.innerHTML = byte_to_string(state.r);

				f_s.innerHTML = ( state.af & 0x80 ) ? 1 : 0;
				f_z.innerHTML = ( state.af & 0x40 ) ? 1 : 0;
				f_h.innerHTML = ( state.af & 0x10 ) ? 1 : 0;
				f_p.innerHTML = ( state.af & 0x04 ) ? 1 : 0;
				f_n.innerHTML = ( state.af & 0x02 ) ? 1 : 0;
				f_c.innerHTML = ( state.af & 0x01 ) ? 1 : 0;

				iff.innerHTML = (( state.iff & 0x02 ) ? '1' : '0' ) + (( state.iff & 0x01 ) ? '1' : '0' );
				imf.innerHTML = (( state.imf & 0x02 ) ? '1' : '0' ) + (( state.imf & 0x01 ) ? '1' : '0' );

				if ( update_styles ) {
					// стили
					r_pc.className = ( state.pc != last_state.pc ) ? 'changed' : '';
					r_sp.className = ( state.sp != last_state.sp ) ? 'changed' : '';
					r_ix.className = ( state.ix != last_state.ix ) ? 'changed' : '';
					r_iy.className = ( state.iy != last_state.iy ) ? 'changed' : '';

					r_hl.className = ( state.hl != last_state.hl ) ? 'changed' : '';
					r_h.className = (( state.hl >> 8 ) != ( last_state.hl >> 8 )) ? 'changed' : '';
					r_l.className = (( state.hl & 0xff ) != ( last_state.hl & 0xff )) ? 'changed' : '';

					r_de.className = ( state.de != last_state.de ) ? 'changed' : '';
					r_d.className = (( state.de >> 8 ) != ( last_state.de >> 8 )) ? 'changed' : '';
					r_e.className = (( state.de & 0xff ) != ( last_state.de & 0xff )) ? 'changed' : '';

					r_bc.className = ( state.bc != last_state.bc ) ? 'changed' : '';
					r_b.className = (( state.bc >> 8 ) != ( last_state.bc >> 8 )) ? 'changed' : '';
					r_c.className = (( state.bc & 0xff ) != ( last_state.bc & 0xff )) ? 'changed' : '';

					r_af.className = ( state.af != last_state.af ) ? 'changed' : '';
					r_a.className = (( state.af >> 8 ) != ( last_state.af >> 8 )) ? 'changed' : '';
					r_f.className = (( state.af & 0xff ) != ( last_state.af & 0xff )) ? 'changed' : '';		

					r_hl_.className = ( state.hl_ != last_state.hl_ ) ? 'changed' : '';
					r_de_.className = ( state.de_ != last_state.de_ ) ? 'changed' : '';
					r_bc_.className = ( state.bc_ != last_state.bc_ ) ? 'changed' : '';
					r_af_.className = ( state.af_ != last_state.af_ ) ? 'changed' : '';

					r_i.className = ( state.i != last_state.i ) ? 'changed' : '';
					r_r.className = ( state.r != last_state.r ) ? 'changed' : '';

					f_s.className = (( state.af & 0x80 ) ^ ( last_state.af & 0x80 )) ? 'changed' : '';
					f_z.className = (( state.af & 0x40 ) ^ ( last_state.af & 0x40 )) ? 'changed' : '';
					f_h.className = (( state.af & 0x10 ) ^ ( last_state.af & 0x10 )) ? 'changed' : '';
					f_p.className = (( state.af & 0x04 ) ^ ( last_state.af & 0x04 )) ? 'changed' : '';
					f_n.className = (( state.af & 0x02 ) ^ ( last_state.af & 0x02 )) ? 'changed' : '';
					f_c.className = (( state.af & 0x01 ) ^ ( last_state.af & 0x01 )) ? 'changed' : '';

					iff.className = ( state.iff != last_state.iff ) ? 'changed' : '';
					imf.className = ( state.imf != last_state.imf ) ? 'changed' : '';
				}

				last_state = state;			
			}
		}

		function DisasmBlock(container, cpu, bus) {
			// public
			this.update = update;

			// private
			$("<?=trace-block?>")
				.appendTo(container);

			var dasm_block = document.getElementById('zxdebug_dasm');

			var buffer_length = 16;
			var buffer = [
				// {
				// 	addr: 0x0038,
				// 	res: { mn: 'NOP', bytes: [ 0x00 ], next: 0x0039 }
				// }
			];

			function get_index_by_addr(addr) {
				for (var i = 0; i < buffer.length; i++) {
					if ( buffer[i].addr == addr ) {
						return i;
					}
				}
				return -1;
			};

			function update() {
				var state = cpu.get_state();

				var pc = state.pc;
				if ( state.prefix_dd || state.prefix_fd || state.prefix_ed ) {
					pc--;
				}

				if ( state.prefix_cb ) {
					pc--;
				}

				var index = get_index_by_addr(pc);
				if (index < 0) {
					buffer.splice(0, buffer.length);
					var addr = pc;
					for (var i = 0; i < buffer_length; i++) {
						buffer[i] = {
							addr: addr,
						 	res: disasm_instruction(bus, addr)
						};
						addr = buffer[i].res.next;
					}
					index = 0;
				}

				update_dasm_block(index);
			}

			function update_dasm_block( active_index ) {
				var dasm_html = "";
				for (var i = 0; i < buffer.length; i++) {
					var addr = buffer[i].addr;
					var res = buffer[i].res;
					var mnemonics = res.mn;
					if ( res.addr !== undefined ) {
						mnemonics = mnemonics.replace('addr', word_to_string(res.addr));
					}
					if ( res.offs !== undefined ) {
						var offset = res.offs;
						if ( offset & 0x80 ) {
							offset = -((offset ^ 0xff) + 1);
						}
						mnemonics = mnemonics.replace(/\+\s*offs/gi, (offset >= 0 ? '+ ' : '- ') + byte_to_string(Math.abs(offset)));
					}
					if ( res.val8 !== undefined ) {
						mnemonics = mnemonics.replace('val8', byte_to_string(res.val8));
					}
					if ( res.val16 !== undefined ) {
						mnemonics = mnemonics.replace('val16', word_to_string(res.val16));
					}
					if ( res.port !== undefined ) {
						mnemonics = mnemonics.replace('port', byte_to_string(res.port));
					}

					dasm_html += '<div class="dasm-line' + ( i == active_index ? '-active' : '' ) + '">';
					dasm_html += '<span class="addr">' + word_to_string(addr) + '</span>';
					dasm_html += '<span class="bytes">' + bytes_to_hex_string(res.bytes) + '</span>';
					dasm_html += '<span class="mnemonics">' + mnemonics + '</span>';
					dasm_html += '</div>';
				}

				dasm_block.innerHTML = dasm_html;
			}
		}

		function MemoryBlock(container, bus) {
			// public
			this.shift_memory_address = shift_memory_address;
			this.change_memory_address = change_memory_address;
			this.update = update;
			this.display_words = function(value) {
				if ( value !== undefined ) {
					display_words = value;
					update();
				}
				else {
					return display_words;
				}
			}

			// private
			$("<?=memory-block?>")
				.appendTo(container);			

			var memory_block = document.getElementById('zxdebug_memory');

			var address = 0x0000;
			var display_words = false;
			var lines = 16;


			function shift_memory_address(offset) {
				address = ( address + offset ) & 0xffff;
				update();
			}

			function change_memory_address() {
				var str_address = prompt('Введите новый адрес: ', '');
				if ( str_address != null ) {
					str_address = str_address.replace(/^\s+|\s+$/g, '');
					var radix = 10;
					if (str_address.length && str_address.charAt(str_address.length - 1).toLowerCase() == 'h') {
						radix = 16;
					}
					if (str_address.length >= 2 & str_address.charAt(0) == '0' && str_address.charAt(1).toLowerCase() == 'x') {
						radix = 16;
					}
					var addr = parseInt(str_address, radix);
					if (!isNaN(addr)) {
						address = addr;
						update();
					}
				}				
			}

			function update() {
				var mem_html = '';

				for (var y = 0; y < lines; y++) {
					var readAddress = ( address + ( y * 8 )) & 0xffff;

					mem_html += '<div class="mem-line">';
					mem_html += '<span class="addr">' + word_to_string(readAddress) + '</span>';
					if ( display_words ) {
						mem_html += '<span class="words">';

						for (var x = 0; x < 4; x++) {
							var lo = bus.mem_read(readAddress);
							var hi = bus.mem_read((readAddress + 1) & 0xffff);
							mem_html += word_to_string((hi << 8) | lo, { hex: true, dont_suffix: true }) + ' ';
							readAddress = ( readAddress + 2 ) & 0xffff;
						}

						mem_html += '</span>';
					}
					else {
						mem_html += '<span class="bytes">';

						for (var x = 0; x < 8; x++) {
							var v8 = bus.mem_read(readAddress);
							mem_html += byte_to_string(v8, { hex: true, dont_suffix: true }) + ' ';
							readAddress = ( readAddress + 1 ) & 0xffff;
						}

						mem_html += '</span>';
					}

					mem_html += '</div>';
				}

				memory_block.innerHTML = mem_html;
			}						
		}

		function WatchBlock(container, bus) {
			// public
			this.update = updateWatches;
			this.addWatch = addWatch;
			this.removeWatches = removeWatches;

			// private
			$("<?=watch-block?>")
				.appendTo(container);

			var $watch_block = $('#zxdebug_watch');

			var watches = [];
			var nextWatchId = 0;

			function updateWatches() {
				$watch_block.empty();

				for ( var i = 0; i < watches.length; i++ ) {
					var watch = watches[i];

					var $item_block = $("<?=watch-item-block?>");
					$item_block.find('.watch-item-selected').val(watch.id);
					$item_block.find('.watch-item-name').text(watch.name);
					$item_block.find('.watch-item-address').text(word_to_string(watch.address));
					switch ( watch.length ) {
						case 'byte': $item_block.find('.watch-item-value').text(byte_to_string(read_memory_byte(bus, watch.address))); break;
						case 'word': $item_block.find('.watch-item-value').text(word_to_string(read_memory_word(bus, watch.address))); break;
					}

					$item_block
						.appendTo($watch_block);
				}
			}

			function addWatch() {
				$dlg = $("<?=watch-add-dialog?>");
				$dlg.dialog({
					autoOpen: true,
					title: 'Add watch',
					modal: true,
					width: 300,
					height: 200,
					buttons: [
						{ text: 'Add', click: add },
						{ text: 'Cancel', click: cancel }
					],
					close: function (e) { $(this).dialog('destroy'); $(this).remove(); }
				});
				$dlg.on('keydown', function (e) { e.stopPropagation(); });
				$dlg.on('keyup', function (e) { e.stopPropagation(); });

				$watch_name = $dlg.find('.watch-name');
				$watch_address = $dlg.find('.watch-address');
				$watch_length = $dlg.find('.watch-length');

				function init() {
					$watch_name.val('');
					$watch_address.val('');
					$watch_length.val('byte');
				}

				function add() {
					var str_address = $.trim($watch_address.val());
					var radix = 10;
					if (str_address.length && str_address.charAt(str_address.length - 1).toLowerCase() == 'h') {
						radix = 16;
					}
					if (str_address.length >= 2 & str_address.charAt(0) == '0' && str_address.charAt(1).toLowerCase() == 'x') {
						radix = 16;
					}
					var address = parseInt(str_address, radix) || 0;

					watches.push({
						id: nextWatchId++,
						name: $watch_name.val(),
						address: address,
						length: $watch_length.val()
					});

					updateWatches();

					$dlg.dialog('close');
					$dlg = null;					
				}

				function cancel() {
					$dlg.dialog('close');
					$dlg = null;
				}
			}

			function removeWatches() {
				var ids_to_remove = $watch_block.find('.watch-item-selected:checked').map(function (i, e) { return +$(e).val(); });
				watches = $.grep(watches, function (watch, i) { return $.inArray(watch.id, ids_to_remove) == -1; });
				updateWatches();
			}
		}

        /////////////////////////////
		// Вспомогательные функции //
		/////////////////////////////

		function byte_to_string(value, options) {
			if ( hex || ( options && options.hex )) {
				var cc1 = (( value >> 4 ) & 0x0f ) + 0x30;
				if ( cc1 > 0x39 ) { cc1 += 0x27; }

				var cc2 = (( value >> 0 ) & 0x0f ) + 0x30;
				if ( cc2 > 0x39 ) { cc2 += 0x27; }

				var s = String.fromCharCode(cc1, cc2);
				if ( !options || !options.dont_suffix ) {
					s += 'h';
				}
				return s;
			}
			else {
				return value.toString();
			}
		}

		function word_to_string(value, options) {
			if ( hex || ( options && options.hex )) {
				var cc1 = (( value >> 12 ) & 0x0f ) + 0x30;
				if ( cc1 > 0x39 ) { cc1 += 0x27; }

				var cc2 = (( value >> 8 ) & 0x0f ) + 0x30;
				if ( cc2 > 0x39 ) { cc2 += 0x27; }

				var cc3 = (( value >> 4 ) & 0x0f ) + 0x30;
				if ( cc3 > 0x39 ) { cc3 += 0x27; }

				var cc4 = (( value >> 0 ) & 0x0f ) + 0x30;
				if ( cc4 > 0x39 ) { cc4 += 0x27; }

				var s = String.fromCharCode(cc1, cc2, cc3, cc4);
				if ( !options || !options.dont_suffix ) {
					s += 'h';
				}
				return s;
			}
			else {
				return value.toString();
			}
		}

		function bytes_to_hex_string (bytes) {
			var s = '';
			for (var i = 0; i < bytes.length; i++) {
				var cc1 = (( bytes[i] >> 4 ) & 0x0f ) + 0x30;
				if ( cc1 > 0x39 ) { cc1 += 0x27; }

				var cc2 = (( bytes[i] >> 0 ) & 0x0f ) + 0x30;
				if ( cc2 > 0x39 ) { cc2 += 0x27; }

				s += String.fromCharCode(cc1, cc2);
			}
			return s;
		}

		function read_opcode_byte(bus, address) {
			return bus.instruction_read(address);
		}
		function read_memory_byte(bus, address) {
			return bus.mem_read(address);
		}

		function read_memory_word(bus, address) {
			return read_memory_byte(bus, address) | ( read_memory_byte(bus, (address + 1) & 0xffff) << 8 ) ;
		}

		function disasm_instruction(bus, address) {
		    var result = {
		        mn: '',
		        next: address,
		        bytes: []
		    };

			var opcode = read_opcode_byte(bus, result.next++);
		    result.bytes.push(opcode);

			var prefix_ix = ( opcode == 0xdd );
			var prefix_iy = ( opcode == 0xfd );
			var prefix_ed = ( opcode == 0xed );
			var prefix_cb = ( opcode == 0xcb );
			var offset = 0;

			if ( prefix_ix || prefix_iy ) {
				opcode = read_opcode_byte(bus, result.next);

				if ( opcode == 0xdd || opcode == 0xfd || opcode == 0xed ) {
					result.mn = 'NOP';
					return result;
				}

		        result.next++;
		        result.bytes.push(opcode);

				if ( opcode == 0xcb ) {
					prefix_cb = true;
					offset = read_memory_byte(bus, result.next++);
		            result.bytes.push(offset);
				}
			}

			if ( prefix_ed ) {
				opcode = read_opcode_byte(bus, result.next++);
		        result.bytes.push(opcode);

		        // 010xx111
		        if ( ( opcode & 0xe7 ) == 0x47 ) {
		            // LD A, I
		            // LD A, R
		            // LD I, A
		            // LD R, A
		            var subcode = (opcode >> 3) & 0x03;
		            switch (subcode) {
		                case 0x00: result.mn = 'LD I, A'; break;
		                case 0x01: result.mn = 'LD R, A'; break;
		                case 0x02: result.mn = 'LD A, I'; break;
		                case 0x03: result.mn = 'LD A, R'; break;
		            }

		            return result;
		        }

		        // 01xxx011
		        if ( (opcode & 0xc7 ) == 0x43 ) {
		            // LD dd, (nn)
		            // LD (nn), dd

		            var to_reg = !!(opcode & 0x08);
		            var dd = (opcode >> 4) & 0x03;

		            var reg_name;
		            switch (dd) {
		            	case 0x00: reg_name = 'BC'; break;
		            	case 0x01: reg_name = 'DE'; break;
		            	case 0x02: reg_name = 'HL'; break;
		            	case 0x03: reg_name = 'SP'; break;
		            }

		            if (to_reg) {
		            	result.mn = 'LD ' + reg_name + ', (addr)';
		            }
		            else { // to_mem
		            	result.mn = 'LD (addr), ' + reg_name;
		            }

		            result.addr = read_memory_word(bus, result.next);
		            result.next += 2;
		            result.bytes.push(result.addr & 0xff);
		            result.bytes.push(result.addr >> 8);

		            return result;
		        }

		        // 101xx000
		        if ( (opcode & 0xe7 ) == 0xa0 ) {
		            // LDI
		            // LDIR
		            // LDD
		            // LDDR

		            var increment = !(opcode & 0x08);
		            var repeat = !!(opcode & 0x10);

		            result.mn = 'LD' + ( increment ? 'I' : 'D' ) + ( repeat ? 'R' : '' );
		            return result;
		        }

		        // 101xx001
		        if ( (opcode & 0xe7 ) == 0xa1 ) {
		            // CPI
		            // CPIR
		            // CPD
		            // CPDR

		            var increment = !(opcode & 0x08);
		            var repeat = !!(opcode & 0x10);

		            result.mn = 'CP' + ( increment ? 'I' : 'D' ) + ( repeat ? 'R' : '' );
		            return result;
		        }

		        // 01xxx100
		        if (( opcode & 0xc7 ) == 0x44 ) {
		            // NEG
		            // * включая все недокументированные варианты опкодов

		            result.mn = 'NEG';
		            return result;
		        }

		        // 01xxx110
		        if ( ( opcode & 0xc7 ) == 0x46 ) {
		            // IM 0
		            // IM 1
		            // IM 2
		            // * включая все недокументированные варианты опкодов

		            switch (( opcode >> 3 ) & 0x03 ) {
		            	case 0x00: result.mn = 'IM 0'; break;
		                case 0x01: result.mn = 'IM 0'; break;
		            	case 0x02: result.mn = 'IM 1'; break;
		            	case 0x03: result.mn = 'IM 2'; break;
		            }

		            return result;
		        }

		        // 01xxx010
		        if ( (opcode & 0xc7 ) == 0x42 ) {
		            // ADC HL, ss
		            // SBC HL, ss

		            var addition = !!(opcode & 0x08);
		            var ss = (opcode >> 4) & 0x03;

		            var reg_name;
		            switch (ss) {
		            	case 0x00: reg_name = 'BC'; break;
		            	case 0x01: reg_name = 'DE'; break;
		            	case 0x02: reg_name = 'HL'; break;
		            	case 0x03: reg_name = 'SP'; break;
		            }

		            result.mn = ( addition ? 'ADC HL, ' : 'SBC HL, ') + reg_name;
		            return result;
		        }

		        // 0110x111
		        if ( (opcode & 0xf7 ) == 0x67 ) {
		            // RLD
		            // RRD

		            var left = !!(opcode & 0x08);

		            result.mn = left ? 'RLD' : 'RRD';
		            return result;
		        }

		        // 01xxx101
		        if ( (opcode & 0xc7 ) == 0x45 ) {
		            // RETI
		            // RETN
		            // * включая все недокументированные варианты опкодов

		            result.mn = 'RET' + (( opcode & 0x80 ) ? 'I' : 'N' );
		            return result;
		        }

		        // 01xxx00x
		        if ( ( opcode & 0xc6 ) == 0x40 ) {
		            // IN r, (C)
		            // OUT (C), r
                	// * IN 0, (C)
                	// * OUT (C), 0

		            var r1 = (opcode >> 3) & 0x07;
		            var cmd_in = !(opcode & 0x01);

		            var reg_name;
		            switch (r1) {
		            	case 0x00: reg_name = 'B'; break;
		            	case 0x01: reg_name = 'C'; break;
		            	case 0x02: reg_name = 'D'; break;
		            	case 0x03: reg_name = 'E'; break;
		            	case 0x04: reg_name = 'H'; break;
		            	case 0x05: reg_name = 'L'; break;
		            	case 0x06: reg_name = '0'; break;
		            	case 0x07: reg_name = 'A'; break;
		            }

		            if (cmd_in) {
		            	result.mn = 'IN ' + reg_name + ', (C)';
		            }
		            else {
		            	result.mn = 'OUT (C), ' + reg_name;
		            }

		            return result;
		        }

		        // 101xx01x
		        if ( (opcode & 0xe6 ) == 0xa2 ) {
		            // INI
		            // INIR
		            // IND
		            // INDR
		            // OUTI
		            // OTIR
		            // OUTD
		            // OTDR

		            var repeat = !!(opcode & 0x10);
		            var increment = !(opcode & 0x08);
		            var cmd_in = !(opcode & 0x01);

		            if (cmd_in) {
		            	result.mn = 'IN' + ( increment ? 'I' : 'D' ) + ( repeat ? 'R' : '' );
		            }
		            else {
		            	result.mn = ( repeat ? 'OT' : 'OUT' ) + ( increment ? 'I' : 'D' ) + ( repeat ? 'R' : '' );
		            }

		            return result;
		        }

		        result.mn = 'NOP';
		        return result;
			}

			if ( prefix_cb ) {
				opcode = read_opcode_byte(bus, result.next++);
		        result.bytes.push(opcode);

		        // 00xxxxxx
		        if ( (opcode & 0xc0 ) == 0x00 ) {
		            // RLC r
		            // RLC (HL)
		            // RLC (IX + d)
		            // RLC (IY + d)
		            // * RLC (IY + d), r
		            // RL r
		            // RL (HL)
		            // RL (IX + d)
		            // RL (IY + d)
		            // * RL (IY + d), r
		            // RRC r
		            // RRC (HL)
		            // RRC (IX + d)
		            // RRC (IY + d)
		            // * RRC (IY + d), r
		            // RR r
		            // RR (HL)
		            // RR (IX + d)
		            // RR (IY + d)
		            // * RR (IY + d), r
		            // SLA r
		            // SLA (HL)
		            // SLA (IX + d)
		            // SLA (IY + d)
		            // * SLA (IY + d), r
		            // * SLL r
		            // * SLL (HL)
		            // * SLL (IX + d)
		            // * SLL (IY + d)                
		            // * SLL (IY + d), r
		            // SRA r
		            // SRA (HL)
		            // SRA (IX + d)
		            // SRA (IY + d)
		            // * SRA (IY + d), r
		            // SRL r
		            // SRL (HL)
		            // SRL (IX + d)
		            // SRL (IY + d)
		            // * SRL (IY + d), r

		            var cmd_shift = !!(opcode & 0x20);
		            var left = !(opcode & 0x08);
		            var carry = !(opcode & 0x10);
		            var r1 = opcode & 0x07;

		            var reg_name;
		            switch (r1) {
		            	case 0x00: reg_name = 'B'; break;
		            	case 0x01: reg_name = 'C'; break;
		            	case 0x02: reg_name = 'D'; break;
		            	case 0x03: reg_name = 'E'; break;
		            	case 0x04: reg_name = 'H'; break;
		            	case 0x05: reg_name = 'L'; break;
		            	case 0x06: reg_name = '(HL)'; break;
		            	case 0x07: reg_name = 'A'; break;
		            }

		            result.mn = ( cmd_shift ? 'S' : 'R' ) + ( left ? 'L' : 'R' );
		            if ( !cmd_shift & carry ) {
		            	result.mn  += 'C';
		            }

		            if ( cmd_shift ) {
		            	result.mn  += ( carry ? 'A' : 'L' );
		            }

		            result.mn += ' ';

		            if ( prefix_ix ) {
		            	result.mn  += '(IX + offs)';
		            	result.offs = offset;
		            }
		            else if ( prefix_iy ) {
		            	result.mn  += '(IY + offs)';
		            	result.offs = offset;
		            }
		            else {
		            	result.mn  += reg_name;
		            }

		            if (( prefix_ix || prefix_iy ) && r1 != 0x06 ) {
		            	result.mn  += ', ' + reg_name;
		            }

		            return result;
		        }

		        // 01xxxxxx
		        if ( (opcode & 0xc0 ) == 0x40 ) {
		            // BIT b, r
		            // BIT b, (HL)
		            // BIT b, (IX + d)
		            // BIT b, (IY + d)

		            var r_dst = opcode & 0x07;
		            var bit = (opcode >> 3) & 0x07;

		            var reg_name;
		            switch (r_dst) {
		            	case 0x00: reg_name = 'B'; break;
		            	case 0x01: reg_name = 'C'; break;
		            	case 0x02: reg_name = 'D'; break;
		            	case 0x03: reg_name = 'E'; break;
		            	case 0x04: reg_name = 'H'; break;
		            	case 0x05: reg_name = 'L'; break;
		            	case 0x06: reg_name = '(HL)'; break;
		            	case 0x07: reg_name = 'A'; break;
		            }

		            result.mn = 'BIT ' + bit + ', ';

		            if (prefix_ix) {
		            	result.mn += '(IX + offs)';
		            	result.offs = offset;
		            }
		            else if (prefix_iy) {
		            	result.mn += '(IY + offs)';
		            	result.offs = offset;
		            }
		            else {
		            	result.mn += reg_name;
		            }

		            if (( prefix_ix || prefix_iy ) && r_dst != 0x06 ) {
		            	result.mn  += ', ' + reg_name;
		            }

		            return result;
		        }

		        // 1xxxxxxx
		        if ( (opcode & 0x80 ) == 0x80 ) {
		            // SET b, r
		            // SET b, (HL)
		            // SET b, (IX + d)
		            // SET b, (IY + d)
		            // * SET b, (IX + d), r
		            // * SET b, (IY + d), r
		            // RES b, r
		            // RES b, (HL)
		            // RES b, (IX + d)
		            // RES b, (IY + d)
		            // * RES b, (IX + d), r
		            // * RES b, (IY + d), r

		            var r_dst = opcode & 0x07;
					var bit = (opcode >> 3) & 0x07;
					var cmd_set = !!(opcode & 0x40);

		            var reg_name;
		            switch (r_dst) {
		            	case 0x00: reg_name = 'B'; break;
		            	case 0x01: reg_name = 'C'; break;
		            	case 0x02: reg_name = 'D'; break;
		            	case 0x03: reg_name = 'E'; break;
		            	case 0x04: reg_name = 'H'; break;
		            	case 0x05: reg_name = 'L'; break;
		            	case 0x06: reg_name = '(HL)'; break;
		            	case 0x07: reg_name = 'A'; break;
		            }

		            result.mn = ( cmd_set ? 'SET ' : 'RES ' ) + bit + ', ';

		            if (prefix_ix) {
		            	result.mn += '(IX + offs)';
		            	result.offs = offset;
		            }
		            else if (prefix_iy) {
		            	result.mn += '(IY + offs)';
		            	result.offs = offset;
		            }
		            else {
		            	result.mn += reg_name;
		            }

		            if (( prefix_ix || prefix_iy ) && r_dst != 0x06 ) {
		            	result.mn  += ', ' + reg_name;
		            }

		            return result;
		        }

		        result.mn = 'NOP';
		        return result;
			}

		    if ( opcode == 0x00 ) {
		        result.mn = 'NOP';
		        return result;
		    }

		    // 01xxxxxx
		    if ( ( opcode & 0xc0 ) == 0x40 ) {
		        // LD r, r'
		        // LD r, (HL)
		        // LD (HL), r
		        // LD r, (IX + d)
		        // LD r, (IY + d)
		        // LD (IX + d), r
		        // LD (IY + d), r
		        // HALT
		        // + недокументированные

		        var r_dst = (opcode >> 3) & 0x07;
		        var r_src = opcode & 0x07;    

		        if (r_src == 0x06 && r_dst == 0x06) {
		            // HALT
		            result.mn = 'HALT';
		            return result;
		        }

		        var r_src_name;
		        switch (r_src) {
		            case 0x00: r_src_name = 'B'; break;
		            case 0x01: r_src_name = 'C'; break;
		            case 0x02: r_src_name = 'D'; break;
		            case 0x03: r_src_name = 'E'; break;
		            case 0x04: 
		                if (prefix_ix && r_dst != 0x06) {
		                    r_src_name = 'IX&h';
		                }
		                else if (prefix_iy && r_dst != 0x06) {
		                    r_src_name = 'IY&h';
		                }
		                else {
		                    r_src_name = 'H'; 
		                }
		                break;

		            case 0x05: 
		                if (prefix_ix && r_dst != 0x06) {
		                    r_src_name = 'IX&l';
		                }
		                else if (prefix_iy && r_dst != 0x06) {
		                    r_src_name = 'IY&l';
		                }
		                else {
		                    r_src_name = 'L'; 
		                }
		                break;

		            case 0x06:
		                var addr;
		                if (prefix_ix) {
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    r_src_name = '(IX + offs)';
		                }
		                else if (prefix_iy) {
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    r_src_name = '(IY + offs)';
		                }
		                else {
		                    r_src_name = '(HL)';
		                }
		                break;

		            case 0x07: r_src_name = 'A'; break;
		        }

		        var r_dst_name;
		        switch (r_dst) {
		            case 0x00: r_dst_name = 'B'; break;
		            case 0x01: r_dst_name = 'C'; break;
		            case 0x02: r_dst_name = 'D'; break;
		            case 0x03: r_dst_name = 'E'; break;
		            case 0x04: 
		                if (prefix_ix && r_src != 0x06) {
		                    r_dst_name = 'IX&h';
		                }
		                else if (prefix_iy && r_src != 0x06) {
		                    r_dst_name = 'IY&h';
		                }
		                else {
		                    r_dst_name = 'H'; 
		                }
		                break;

		            case 0x05: 
		                if (prefix_ix && r_src != 0x06) {
		                    r_dst_name = 'IX&l';
		                }
		                else if (prefix_iy && r_src != 0x06) {
		                    r_dst_name = 'IY&l';
		                }
		                else {
		                    r_dst_name = 'L'; 
		                }
		                break;

		            case 0x06: 
		                var addr;
		                if (prefix_ix) {
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    r_dst_name = '(IX + offs)';
		                }
		                else if (prefix_iy) {
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    r_dst_name = '(IY + offs)';
		                }
		                else {
		                    r_dst_name = '(HL)';
		                }
		                break;

		            case 0x07: r_dst_name = 'A'; break;
		        }            

		        result.mn = 'LD ' + r_dst_name + ', ' + r_src_name;

		        return result;
		    }

		    // 00xxx110
		    if ( ( opcode & 0xc7 ) == 0x06 ) {
		        // LD r, n
		        // LD (HL), n
		        // LD (IX + d), n
		        // LD (IY + d), n
		        // + недокументированные

		        var r_dst = (opcode >> 3) & 0x07;
		        var r_dst_name;
		        switch (r_dst) {
		            case 0x00: r_dst_name = 'B'; break;
		            case 0x01: r_dst_name = 'C'; break;
		            case 0x02: r_dst_name = 'D'; break;
		            case 0x03: r_dst_name = 'E'; break;
		            case 0x04: 
		                if (prefix_ix) {
		                    r_dst_name = 'IX&h';
		                }
		                else if (prefix_iy) {
		                    r_dst_name = 'IY&h';
		                }
		                else {
		                    r_dst_name = 'H';
		                }
		                break;

		            case 0x05: 
		                if (prefix_ix) {
		                    r_dst_name = 'IX&l';
		                }
		                else if (prefix_iy) {
		                    r_dst_name = 'IY&l';
		                }
		                else {
		                    r_dst_name = 'L';
		                }
		                break;

		            case 0x06: 
		                var addr;
		                if (prefix_ix) {
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    r_dst_name = '(IX + offs)';
		                }
		                else if (prefix_iy) {
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    r_dst_name = '(IY + offs)';
		                }
		                else {
		                    r_dst_name = '(HL)';
		                }                    
		                break;

		            case 0x07: r_dst_name = 'A'; break;
		        }

		        result.val8 = read_memory_byte(bus, result.next++);
		        result.bytes.push(result.val8);
		        result.mn = 'LD ' + r_dst_name + ', val8';

		        return result;
		    }

		    // 00xxx010
		    if ( (opcode & 0xc7 ) == 0x02 ) {
		        // LD A, (BC)
		        // LD A, (DE)
		        // LD A, (nn)
		        // LD HL, (nn)
		        // LD IX, (nn)
		        // LD IY, (nn)

		        // LD (BC), A
		        // LD (DE), A
		        // LD (nn), A
		        // LD (nn), HL
		        // LD (nn), IX
		        // LD (nn), IY

		        var to_reg = !!(opcode & 0x08);
		        var r_code = (opcode >> 4) & 0x03;

		        if (to_reg) {
		            switch (r_code) {
		                case 0x00: result.mn = 'LD A, (BC)'; break;
		                case 0x01: result.mn = 'LD A, (DE)'; break;
		                case 0x02: 
		                    // HL, (nn)
		                    var addr = read_memory_word(bus, result.next);
		                    result.next += 2;
		                    result.bytes.push(addr & 0xff);
		                    result.bytes.push(addr >> 8);

		                    if (prefix_ix) {
		                        result.mn = 'LD IX, (addr)';
		                    }
		                    else if (prefix_iy) {
		                        result.mn = 'LD IY, (addr)';
		                    }
		                    else {
		                        result.mn = 'LD HL, (addr)';
		                    }

		                    result.addr = addr;
		                    break;

		                case 0x03:
		                    // A, (nn)
		                    var addr = read_memory_word(bus, result.next);
		                    result.next += 2;
		                    result.bytes.push(addr & 0xff);
		                    result.bytes.push(addr >> 8);
		                    result.mn = 'LD A, (addr)';
		                    result.addr = addr;
		                    break;
		            }
		        }
		        else {
		            switch (r_code) {
		                case 0x00: result.mn = 'LD (BC), A'; break;
		                case 0x01: result.mn = 'LD (DE), A'; break;
		                case 0x02:
		                    // (nn), HL
		                    var addr = read_memory_word(bus, result.next);
		                    result.next += 2;
		                    result.bytes.push(addr & 0xff);
		                    result.bytes.push(addr >> 8);

		                    if (prefix_ix) {
		                        result.mn = 'LD (addr), IX'
		                    }
		                    else if (prefix_iy) {
		                        result.mn = 'LD (addr), IY'
		                    }
		                    else {
		                        result.mn = 'LD (addr), HL'
		                    }

		                    result.addr = addr;
		                    break;

		                case 0x03:
		                    // (nn), A
		                    var addr = read_memory_word(bus, result.next);
		                    result.next += 2;
		                    result.bytes.push(addr & 0xff);
		                    result.bytes.push(addr >> 8);

		                    result.mn = 'LD (addr), A';
		                    result.addr = addr;
		                    break;
		            }
		        }

		        return result;
		    }

		    // 00xx0001
		    if ( ( opcode & 0xcf ) == 0x01 ) {
		        // LD dd, nn
		        // LD IX, nn
		        // LD IY, nn

                var value = read_memory_word(bus, result.next);
                result.next += 2;
                result.bytes.push(value & 0xff);
                result.bytes.push(value >> 8);

		        var dd = (opcode >> 4) & 0x03;

		        var reg_name;
		        switch (dd) {
		            case 0x00: reg_name = 'BC'; break;
		            case 0x01: reg_name = 'DE'; break;
		            case 0x02: 
		                if (prefix_ix) {
		                    reg_name = 'IX';
		                }
		                else if (prefix_iy) {
		                    reg_name = 'IY'
		                }
		                else {
		                    reg_name = 'HL'
		                }
		                break;

		            case 0x03: reg_name = 'SP'; break;
		        }

		        result.mn = 'LD ' + reg_name + ', val16';
		        result.val16 = value;
		        return result;
		    }

		    // 11xx0x01
		    if ( (opcode & 0xcb) == 0xc1 ) {
		        // PUSH qq
		        // PUSH IX
		        // PUSH IY
		        // POP qq
		        // POP IX
		        // POP IY

		        var to_reg = !(opcode & 0x04);
		        var qq = (opcode >> 4) & 0x03;

		        var reg_name;
		        switch (qq) {
		            case 0x00: reg_name = 'BC'; break;
		            case 0x01: reg_name = 'DE'; break;
		            case 0x02:
		                if (prefix_ix) {
		                    reg_name = 'IX';
		                }
		                else if (prefix_iy) {
		                    reg_name = 'IY';
		                }
		                else {
		                    reg_name = 'HL';
		                }
		                break;

		            case 0x03: reg_name = 'AF'; break;
		        }

		        result.mn = ( to_reg ? 'POP ' : 'PUSH ' ) + reg_name;
		        return result;
		    }

		    // 11111001
		    if ( opcode == 0xf9 ) {
		        // LD SP, HL
		        // LD SP, IX
		        // LD SP, IY

		        if (prefix_ix) {
		            result.mn = 'LD SP, IX';
		        }
		        else if (prefix_iy) {
		            result.mn = 'LD SP, IY';
		        }
		        else {
		            result.mn = 'LD SP, HL';
		        }

		        return result;
		    }

		    if ( opcode == 0xeb ) {
		        // EX DE, HL
		        result.mn = 'EX DE, HL';
		        return result;
		    }

		    if ( opcode == 0x08 ) {
		        // EX AF, AF'
		        result.mn = 'EX AF, AF\'';
		        return result;
		    }

		    if ( opcode == 0xd9 ) {
		        // EXX
		        result.mn = 'EXX';
		        return result;
		    }

		    if ( opcode == 0xe3 ) {
		        // EX (SP), HL
		        // EX (SP), IX
		        // EX (SP), IY

		        if (prefix_ix) {
		            result.mn = 'EX (SP), IX';
		        }
		        else if (prefix_iy) {
		            result.mn = 'EX (SP), IY';
		        }
		        else {
		            result.mn = 'EX (SP), HL';
		        }

		        return result;
		    }

		    // 10xxxxxx and 11xxx110
		    if ( ( opcode & 0xc0 ) == 0x80 || ( opcode & 0xc7 ) == 0xc6 ) {
		        // ADD A, r
		        // ADD A, n
		        // ADD A, (HL)
		        // ADD A, (IX + d)
		        // ADD A, (IY + d)
		        // ADC A, r
		        // ADC A, n
		        // ADC A, (HL)
		        // ADC A, (IX + d)
		        // ADC A, (IY + d)
		        // SUB r
		        // SUB n
		        // SUB (HL)
		        // SUB (IX + d)
		        // SUB (IY + d)
		        // SBC A, r
		        // SBC A, n
		        // SBC A, (HL)
		        // SBC A, (IX + d)
		        // SBC A, (IY + d)
		        // AND r
		        // AND n
		        // AND (HL)
		        // AND (IX + d)
		        // AND (IY + d)
		        // OR r
		        // OR n
		        // OR (HL)
		        // OR (IX + d)
		        // OR (IY + d)
		        // XOR r
		        // XOR n
		        // XOR (HL)
		        // XOR (IX + d)
		        // XOR (IY + d)                
		        // CP r
		        // CP n
		        // CP (HL)
		        // CP (IX + d)
		        // CP (IY + d)
		        // + недокументированные

		        var operand;
		        var explicit_operand = !!(opcode & 0x40);
		        if (explicit_operand) {
		            operand = 'val8';
		            result.val8 = read_memory_byte(bus, result.next++); // n
		            result.bytes.push(result.val8);
		        }
		        else {
		            var r1 = opcode & 0x07;
		            switch (r1) {
		                case 0x00: operand = 'B'; break; // B
		                case 0x01: operand = 'C'; break; // C
		                case 0x02: operand = 'D'; break; // D
		                case 0x03: operand = 'E'; break; // E
		                case 0x04: 
		                    if (prefix_ix) {
		                        operand = 'IX&h'; // IXh
		                    }
		                    else if (prefix_iy) {
		                        operand = 'IY&h'; // IYh
		                    }
		                    else {
		                        operand = 'H'; // H
		                    }
		                    break;

		                case 0x05: 
		                    if (prefix_ix) {    
		                        operand = 'IX&l'; // IXl
		                    }
		                    else if (prefix_iy) {
		                        operand = 'IY&l'; // IYl
		                    }
		                    else {
		                        operand = 'L'; // L
		                    }
		                    break;

		                case 0x06:
		                    if (prefix_ix) {
		                        operand = '(IX + offs)'; // (IX + d)
		                        result.offs = read_memory_byte(bus, result.next++);
		                        result.bytes.push(result.offs);
		                    }
		                    else if (prefix_iy) {
		                        operand = '(IY + offs)'; // (IY + d)
		                        result.offs = read_memory_byte(bus, result.next++);
		                        result.bytes.push(result.offs);
		                    }
		                    else {
		                        operand = operand = '(HL)'; // (HL)
		                    }
		                    break;

		                case 0x07: operand = 'A'; break; // A
		            }
		        }

		        var logic = !!(opcode & 0x20);
		        if (logic) { // logic
		            var subcode = (opcode >> 3) & 0x03;

		            switch (subcode) {
		                case 0x00: result.mn = 'AND ' + operand; break;
		                case 0x01: result.mn = 'XOR ' + operand; break;
		                case 0x02: result.mn = 'OR ' + operand; break;
		                case 0x03: result.mn = 'CP ' + operand; break;
		            }
		        }
		        else { // arithmetic
		            var care_case = !!(opcode & 0x08);
		            var addition = !(opcode & 0x10);

		            if (addition) {
		                result.mn = ( care_case ? 'ADC A, ' : 'ADD A, ' ) + operand;
		            }
		            else {
		                result.mn = ( care_case ? 'SBC A, ' : 'SUB ' ) + operand;
		            }
		        }

		        return result;
		    }

		    // 00xxx10x
		    if ( (opcode & 0xc6 ) == 0x04 ) {
		        // INC r
		        // INC (HL)
		        // INC (IX + d)
		        // INC (IY + d)
		        // DEC r
		        // DEC (HL)
		        // DEC (IX + d)
		        // DEC (IY + d)
		        // + недокументированные


		        var r1 = (opcode >> 3) & 0x07;
		        var cmd_inc = !(opcode & 0x01);

		        var reg_name;
		        switch (r1) {
		            case 0x00: reg_name = 'B'; break;
		            case 0x01: reg_name = 'C'; break;
		            case 0x02: reg_name = 'D'; break;
		            case 0x03: reg_name = 'E'; break;
		            case 0x04:
		                if (prefix_ix) {
		                    reg_name = 'IX&h';
		                }
		                else if (prefix_iy) {
		                    reg_name = 'IY&h';
		                }
		                else {
		                    reg_name = 'H';
		                }
		                break;

		            case 0x05:
		                if (prefix_ix) {
		                    reg_name = 'IX&l';
		                }
		                else if (prefix_iy) {
		                    reg_name = 'IY&l';
		                }
		                else {
		                    reg_name = 'L';
		                }
		                break;   

		            case 0x06:
		                if (prefix_ix) {
		                    // (IX + d)
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    reg_name = '(IX + offs)';
		                }
		                else if (prefix_iy) {
		                    // (IY + d)
		                    result.offs = read_memory_byte(bus, result.next++);
		                    result.bytes.push(result.offs);
		                    reg_name = '(IY + offs)';
		                }
		                else {
		                    // (HL)
		                    reg_name = '(HL)';
		                }
		                break;

		            case 0x07: reg_name = 'A'; break;
		        }

		        result.mn = ( cmd_inc ? 'INC ' : 'DEC ' ) + reg_name;
		        return result;
		    }

		    // 1111x011
		    if ( (opcode & 0xf7 ) == 0xf3 ) {
		        // DI
		        // EI

		        var allow_int = !!(opcode & 0x08);
		        result.mn = allow_int ? 'EI' : 'DI';
		        return result;
		    }

		    // 00100111
		    if ( opcode == 0x27 ) {
		        // DAA
		        result.mn = 'DAA';
		        return result;
		    }

		    // 00101111
		    if ( opcode == 0x2f ) {
		        // CPL

		        result.mn = 'CPL';
		        return result;
		    }

		    // 00111111
		    if ( opcode == 0x3f ) {
		        // CCF

		        result.mn = 'CCF';
		        return result;
		    }

		    // 00110111
		    if ( opcode == 0x37 ) {
		        // SCF

		        result.mn = 'SCF';
		        return result;
		    }

		    // 00xx1001
		    if ( ( opcode & 0xcf ) == 0x09 ) {
		        // ADD HL, ss
		        // ADD IX, pp
		        // ADD IY, rr

		        var ss = (opcode >> 4) & 0x03;
		        var operand;
		        switch (ss) {
		            case 0x00: operand = 'BC'; break; // BC
		            case 0x01: operand = 'DE'; break; // DE
		            case 0x02:
		                if (prefix_ix) {
		                    operand = 'IX'; // IX
		                }
		                else if (prefix_iy) {
		                    operand = 'IY'; // IY
		                }
		                else {
		                    operand = 'HL'; // HL
		                }
		                break;

		            case 0x03: operand = 'SP'; break; // SP
		        }

		        if (prefix_ix) {
		            result.mn = 'ADD IX, ' + operand;
		        }
		        else if (prefix_iy) {
		            result.mn = 'ADD IY, ' + operand;
		        }
		        else {
		            result.mn = 'ADD HL, ' + operand;
		        }

		        return result;
		    }

		    // 00xxx011
		    if ( (opcode & 0xc7 ) == 0x03 ) {
		        // INC ss
		        // INC IX
		        // INC IY
		        // DEC ss
		        // DEC IX
		        // DEC IY

		        var cmd_inc = !(opcode & 0x08);
		        var ss = (opcode >> 4) & 0x03;

		        var reg_name;
		        switch (ss) {
		            case 0x00: reg_name = 'BC'; break; // BC
		            case 0x01: reg_name = 'DE'; break; // DE
		            case 0x02:
		                if (prefix_ix) {
		                    reg_name = 'IX'; // IX
		                }
		                else if (prefix_iy) {
		                    reg_name = 'IY'; // IY
		                }
		                else {
		                    reg_name = 'HL'; // HL
		                }
		                break;

		            case 0x03: reg_name = 'SP'; break; // SP
		        }

		        result.mn = ( cmd_inc ? 'INC ' : 'DEC ' ) + reg_name;
		        return result;
		    }

		    // 000xx111
		    if ( (opcode & 0xe7 ) == 0x07 ) {
		        // RLCA
		        // RLA
		        // RRCA
		        // RRA

		        var left = !(opcode & 0x08);
		        var carry = !(opcode & 0x10);

		        result.mn = 'R' + ( left ? 'L' : 'R' ) + ( carry ? 'C' : '' ) + 'A';
		        return result;
		    }

		    // 11000011
		    if ( opcode == 0xc3 ) {
		        // JP nn

                result.addr = read_memory_word(bus, result.next);
                result.next += 2;
                result.bytes.push(result.addr & 0xff);
                result.bytes.push(result.addr >> 8);
		        result.mn = 'JP addr';
		        return result;
		    }

		    // 11xxx010
		    if ( (opcode & 0xc7 ) == 0xc2 ) {
		        // JP cc, nn

		        var condition_code = (opcode >> 3) & 0x07;

		        var condition;
		        switch (condition_code) {
		            case 0x00: condition = 'NZ'; break; // NZ
		            case 0x01: condition = 'Z'; break; // Z
		            case 0x02: condition = 'NC'; break; // NC
		            case 0x03: condition = 'C'; break; // C
		            case 0x04: condition = 'PO'; break; // PO
		            case 0x05: condition = 'PE'; break; // PE
		            case 0x06: condition = 'P'; break; // P
		            case 0x07: condition = 'M'; break; // M
		        }

                result.addr = read_memory_word(bus, result.next);
                result.next += 2;
                result.bytes.push(result.addr & 0xff);
                result.bytes.push(result.addr >> 8);
		        result.mn = 'JP ' + condition + ', addr';
		        return result;
		    }

		    // 00xxx000 where xxx >= 010
		    if ( ( opcode & 0xc7 ) == 0x00 && ( opcode & 0x38 ) >= 0x10 ) {
		        // JR e
		        // JR C, e
		        // JR NC, e
		        // JR Z, e
		        // JR NZ, e
		        // DJNZ e

		        var condition_code = (opcode >> 3) & 0x07;

		        var condition;
		        switch (condition_code) {
		            case 0x02: result.mn = 'DJNZ addr'; break;
		            case 0x03: result.mn = 'JR addr'; break; // JR e
		            case 0x04: result.mn = 'JR NZ, addr'; break; // JR NZ, e
		            case 0x05: result.mn = 'JR Z, addr'; break; // JR Z, e
		            case 0x06: result.mn = 'JR NC, addr'; break; // JR NC, e
		            case 0x07: result.mn = 'JR C, addr'; break; // JR C, e
		        }

		        var offset = read_memory_byte(bus, result.next++);
		        result.bytes.push(offset);

		        result.addr = result.next;
		        if ( offset & 0x80 ) {
		            result.addr -= ((offset ^ 0xff) + 1);
		        }
		        else {
		            result.addr += offset;
		        }

		        return result;
		    }

		    // 11101001
		    if ( opcode == 0xe9 ) {
		        // JP (HL)
		        // JP (IX)
		        // JP (IY)
		        // * это не косвенная адресация, читать мнемонику без скобок!

		        if (prefix_ix) {
		            result.mn = 'JP (IX)';
		        }
		        else if (prefix_iy) {
		            result.mn = 'JP (IY)';
		        }
		        else {
		            result.mn = 'JP (HL)';
		        }

		        return result;
		    }

		    // 11001101
		    if ( opcode == 0xcd ) {
		        // CALL nn

                result.addr = read_memory_word(bus, result.next);
                result.next += 2;
                result.bytes.push(result.addr & 0xff);
                result.bytes.push(result.addr >> 8);
		        result.mn = 'CALL addr';
		        return result;
		    }

		    // 11xxx100
		    if ( ( opcode & 0xc7 ) == 0xc4 ) {
		        // CALL cc, nn

		        var condition_code = (opcode >> 3) & 0x07;

		        var condition;
		        switch (condition_code) {
		            case 0x00: condition = 'NZ'; break; // NZ
		            case 0x01: condition = 'Z'; break; // Z
		            case 0x02: condition = 'NC'; break; // NC
		            case 0x03: condition = 'C'; break; // C
		            case 0x04: condition = 'PO'; break; // PO
		            case 0x05: condition = 'PE'; break; // PE
		            case 0x06: condition = 'P'; break; // P
		            case 0x07: condition = 'M'; break; // M
		        }

                result.addr = read_memory_word(bus, result.next);
                result.next += 2;
                result.bytes.push(result.addr & 0xff);
                result.bytes.push(result.addr >> 8);
		        result.mn = 'CALL ' + condition + ', addr';
		        return result;
		    }

		    // 11001001
		    if ( opcode == 0xc9 ) {
		        // RET

		        result.mn = 'RET';
		        return result;
		    }

		    // 11xxx000
		    if ( ( opcode & 0xc7 ) == 0xc0 ) {
		        // RET cc

		        var condition_code = (opcode >> 3) & 0x07;

		        var condition;
		        switch (condition_code) {
		            case 0x00: condition = 'NZ'; break; // NZ
		            case 0x01: condition = 'Z'; break; // Z
		            case 0x02: condition = 'NC'; break; // NC
		            case 0x03: condition = 'C'; break; // C
		            case 0x04: condition = 'PO'; break; // PO
		            case 0x05: condition = 'PE'; break; // PE
		            case 0x06: condition = 'P'; break; // P
		            case 0x07: condition = 'M'; break; // M
		        }

		        result.mn = 'RET ' + condition;
		        return result;
		    }

		    // 11xxx111
		    if ( (opcode & 0xc7 ) == 0xc7 ) {
		        // RST p

		        var rst_code = (opcode >> 3) & 0x07;
		        var addr = rst_code << 3; // code * 8

		        result.mn = 'RST addr';
		        result.addr = addr;
		        return result;
		    }

		    // 1101x011
		    if ( ( opcode & 0xf7 ) == 0xd3 ) {
		        // IN A, (n)
		        // OUT (n), A

		        var port_low = read_memory_byte(bus, result.next++);

		        result.bytes.push(port_low);
		        result.port = port_low;

		        var cmd_in = !!(opcode & 0x08);
		        if (cmd_in) {
		            // IN
		            result.mn = 'IN A, (port)'
		        }
		        else {
		            // OUT
		            result.mn = 'OUT (port), A'
		        }

		        return result;
		    } 

		    result.mn = 'UNKNOWN';
		    return result;
		}		
	})();
</script>